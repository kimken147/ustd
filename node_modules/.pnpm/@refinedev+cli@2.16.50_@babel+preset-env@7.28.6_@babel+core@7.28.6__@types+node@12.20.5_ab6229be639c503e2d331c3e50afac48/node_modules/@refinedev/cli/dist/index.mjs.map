{"version":3,"sources":["../src/definitions/projectTypes.ts","../src/definitions/uiFrameworks.ts","../src/definitions/package.ts","../src/utils/swizzle/import.ts","../src/utils/swizzle/appendAfterImports.ts","../src/utils/swizzle/getFileContent.ts"],"sourcesContent":["export enum ProjectTypes {\n  REACT_SCRIPT = \"react-scripts\",\n  REMIX = \"remix\",\n  REMIX_VITE = \"remix-vite\",\n  REMIX_SPA = \"remix-spa\",\n  NEXTJS = \"nextjs\",\n  VITE = \"vite\",\n  CRACO = \"craco\",\n  PARCEL = \"parcel\",\n  UNKNOWN = \"unknown\",\n}\n","export enum UIFrameworks {\n  ANTD = \"antd\",\n  MUI = \"mui\",\n  MANTINE = \"mantine\",\n  CHAKRA = \"chakra-ui\",\n}\n","export enum PackageManagerTypes {\n  NPM = \"npm\",\n  YARN = \"yarn\",\n  PNPM = \"pnpm\",\n}\n\n/**\n * type of `npm outdated` command response\n */\nexport type NpmOutdatedResponse = Record<\n  string,\n  {\n    current: string;\n    wanted: string;\n    latest: string;\n    dependent: string;\n    location: string;\n  }\n>;\n\nexport type RefinePackageInstalledVersionData = {\n  name: string;\n  /**\n   * version of the package that is currently installed. Without semver range wildcard.\n   */\n  current: string;\n  /**\n   * version that the user wants to update to. Without semver range wildcard.\n   * e.g. `^1.0.0` in `package.json` resolves to `1.0.1` in the this field.\n   */\n  wanted: string;\n  /**\n   * latest version of the package available on npm\n   */\n  latest: string;\n  /**\n   * changelog url\n   */\n  changelog?: string;\n  /**\n   * dependent package name\n   */\n  dependent: string;\n  /**\n   * location of the package\n   */\n  location: string;\n};\n\n/**\n * key is the script name and value is the script command\n */\nexport type PackageDependency = Record<string, string>;\n\nexport type PackageJson = {\n  name: string;\n  version: string;\n  scripts?: Record<string, string>;\n  dependencies?: PackageDependency;\n  devDependencies?: PackageDependency;\n  peerDependencies?: PackageDependency;\n  refine?: {\n    projectId?: string;\n  };\n};\n","const packageRegex =\n  /import(?:\\s+(type))?\\s*(?:([^\\s\\{\\},]+)\\s*(?:,\\s*)?)?(\\{[^}]+\\})?\\s*(?:\\*\\s*as\\s+([^\\s\\{\\}]+)\\s*)?from\\s*['\"]([^'\"]+)['\"];?/g;\n\nconst nameChangeRegex = /((?:\\w|\\s|_)*)( as )((?:\\w|\\s|_)*)( |,)?/g;\n\nexport type ImportMatch = {\n  statement: string;\n  importPath: string;\n  defaultImport?: string;\n  namedImports?: string;\n  namespaceImport?: string;\n  isType?: boolean;\n};\n\nexport type NameChangeMatch = {\n  statement: string;\n  fromName: string;\n  toName: string;\n  afterCharacter?: string;\n};\n\nexport const getImports = (content: string): Array<ImportMatch> => {\n  const matches = content.matchAll(packageRegex);\n\n  const imports: Array<ImportMatch> = [];\n\n  for (const match of matches) {\n    const [\n      statement,\n      typePrefix,\n      defaultImport,\n      namedImports,\n      namespaceImport,\n      importPath,\n    ] = match;\n\n    imports.push({\n      isType: typePrefix === \"type\",\n      statement,\n      importPath,\n      ...(defaultImport && { defaultImport }),\n      ...(namedImports && { namedImports }),\n      ...(namespaceImport && { namespaceImport }),\n    });\n  }\n\n  return imports?.filter(Boolean);\n};\n\nexport const getNameChangeInImport = (\n  namedImportString: string,\n): Array<NameChangeMatch> => {\n  const matches = namedImportString.matchAll(nameChangeRegex);\n\n  const nameChanges: Array<NameChangeMatch> = [];\n\n  for (const match of matches) {\n    const [statement, fromName, _as, toName, afterCharacter] = match;\n\n    nameChanges.push({\n      statement,\n      fromName: fromName.trim(),\n      toName: toName.trim(),\n      afterCharacter,\n    });\n  }\n\n  return nameChanges;\n};\n\n/** @internal */\nexport const getContentBeforeImport = (\n  content: string,\n  importMatch: ImportMatch,\n): string => {\n  // get the content before the import statement and between the last import statement and the current one\n  const contentBeforeImport = content.substring(\n    0,\n    content.indexOf(importMatch.statement),\n  );\n  // get the last import statement\n  const lastImportStatement = getImports(contentBeforeImport).pop();\n\n  // if there is no last import statement, return the content before the current import statement\n  if (!lastImportStatement) {\n    return contentBeforeImport;\n  }\n\n  // get the content between the last import statement and the current one\n  const contentBetweenImports = contentBeforeImport.substring(\n    contentBeforeImport.indexOf(lastImportStatement?.statement) +\n      lastImportStatement?.statement?.length,\n  );\n\n  // return the content before the current import statement and between the last import statement and the current one\n  return contentBetweenImports;\n};\n\n/** @internal */\nexport const isImportHasBeforeContent = (\n  content: string,\n  importMatch: ImportMatch,\n): boolean => {\n  const contentBeforeImport = importMatch\n    ? getContentBeforeImport(content, importMatch)\n    : \"\";\n\n  return !!contentBeforeImport.trim();\n};\n\nconst IMPORT_ORDER = [\"react\", \"@refinedev/core\", \"@refinedev/\"];\n\nexport const reorderImports = (content: string): string => {\n  let newContent = content;\n  // imports can have comments before them, we need to preserve those comments and import statements.\n  // so we need to filter out the imports with comments before.\n  const allImports = getImports(content);\n  // remove `import type` imports\n  const allModuleImports = allImports.filter(\n    (importMatch) => !importMatch.isType,\n  );\n  const typeImports = allImports.filter((importMatch) => importMatch.isType);\n\n  const importsWithBeforeContent: ImportMatch[] = [];\n  const importsWithoutBeforeContent: ImportMatch[] = [];\n\n  // // remove all type imports\n  typeImports.forEach((importMatch) => {\n    newContent = newContent.replace(`${importMatch.statement}\\n`, \"\");\n  });\n\n  allModuleImports.forEach((importMatch) => {\n    if (isImportHasBeforeContent(newContent, importMatch)) {\n      importsWithBeforeContent.push(importMatch);\n    } else {\n      importsWithoutBeforeContent.push(importMatch);\n    }\n  });\n\n  // insertion point is the first import statement, others will be replaced to empty string and added to the first import line\n  const insertionPoint = newContent.indexOf(\n    importsWithoutBeforeContent?.[0]?.statement,\n  );\n\n  // remove all the imports without comments before\n  importsWithoutBeforeContent.forEach((importMatch) => {\n    newContent = newContent.replace(importMatch.statement, \"\");\n  });\n\n  // we need to merge the imports from the same package unless one of them is a namespace import]\n  const importsByPackage = importsWithoutBeforeContent.reduce(\n    (acc, importMatch) => {\n      const { importPath } = importMatch;\n\n      if (acc[importPath]) {\n        acc[importPath].push(importMatch);\n      } else {\n        acc[importPath] = [importMatch];\n      }\n\n      return acc;\n    },\n    {} as Record<string, ImportMatch[]>,\n  );\n\n  // merge the imports from the same package\n  const mergedImports = Object.entries(importsByPackage).map(\n    ([importPath, importMatches]) => {\n      // example: A\n      const defaultImport = importMatches.find(\n        (importMatch) => importMatch.defaultImport,\n      );\n\n      // example: * as A\n      const namespaceImport = importMatches.find(\n        (importMatch) => importMatch.namespaceImport,\n      );\n\n      // example: { A, B }\n      // example: { A as C, B }\n      // content inside the curly braces should be merged\n      const namedImports = importMatches\n        .filter((importMatch) => importMatch.namedImports)\n        .map((importMatch) => {\n          // remove curly braces and trim then split by comma (can be multiline)\n          const namedImports = (importMatch.namedImports ?? \"\")\n            .replace(/{|}/g, \"\")\n            .trim()\n            .split(\",\")\n            .map((namedImport) => namedImport.trim());\n\n          return namedImports.filter(Boolean).join(\", \");\n        })\n        .join(\", \");\n\n      let importLine = \"\";\n\n      // default import and namespace import can not be used together\n      // but we can use default import and named imports together\n      // so we need to merge them\n      if (namespaceImport) {\n        importLine += `${namespaceImport.statement}\\n`;\n      }\n      if (defaultImport || namedImports) {\n        if (defaultImport && namedImports) {\n          importLine += `import ${defaultImport.defaultImport}, { ${namedImports} } from \"${importMatches[0].importPath}\";\\n`;\n        } else if (defaultImport) {\n          importLine += `import ${defaultImport.defaultImport} from \"${importMatches[0].importPath}\";\\n`;\n        } else {\n          importLine += `import { ${namedImports} } from \"${importMatches[0].importPath}\";\\n`;\n        }\n      }\n\n      return [importPath, importLine] as [\n        importPath: string,\n        importLine: string,\n      ];\n    },\n  );\n\n  // sort the imports without comments before\n  // sort should be done by IMPORT_ORDER and alphabetically\n  // priority is exact match in IMPORT_ORDER, then includes match in IMPORT_ORDER, then alphabetically\n  const sortedImports = [...mergedImports].sort(\n    ([aImportPath], [bImportPath]) => {\n      const aImportOrderIndex = IMPORT_ORDER.findIndex((order) =>\n        aImportPath.includes(order),\n      );\n      const bImportOrderIndex = IMPORT_ORDER.findIndex((order) =>\n        bImportPath.includes(order),\n      );\n\n      if (aImportOrderIndex === bImportOrderIndex) {\n        return aImportPath.localeCompare(bImportPath);\n      }\n\n      if (aImportOrderIndex === -1) {\n        return 1;\n      }\n\n      if (bImportOrderIndex === -1) {\n        return -1;\n      }\n\n      return aImportOrderIndex - bImportOrderIndex;\n    },\n  );\n\n  // add the sorted imports to the insertion point keep the before and after content\n  // add the type imports after the sorted imports\n  const joinedModuleImports = sortedImports\n    .map(([, importLine]) => importLine)\n    .join(\"\");\n  const joinedTypeImports = [\n    ...typeImports.map((importMatch) => importMatch.statement),\n    \"\",\n  ].join(\"\\n\");\n\n  newContent =\n    newContent.substring(0, insertionPoint) +\n    joinedModuleImports +\n    joinedTypeImports +\n    newContent.substring(insertionPoint);\n\n  return newContent;\n};\n","import { getImports } from \"./import\";\n\nexport const appendAfterImports = (content: string, append: string): string => {\n  const imports = getImports(content);\n  const lastImport = imports[imports.length - 1];\n\n  const lastImportIndex = lastImport\n    ? content.indexOf(lastImport.statement)\n    : content.length - 1;\n\n  return `${content.slice(\n    0,\n    lastImportIndex + lastImport?.statement.length,\n  )}\\n${append}\\n${content.slice(\n    lastImportIndex + lastImport?.statement.length,\n  )}`;\n};\n","import { readFileSync } from \"fs-extra\";\nimport { join } from \"path\";\n\nexport function getFileContent(\n  this: undefined | { absolutePackageDir?: string },\n  path: string,\n): string | undefined {\n  if (!this?.absolutePackageDir) {\n    return undefined;\n  }\n  try {\n    return readFileSync(join(this.absolutePackageDir, path)).toString();\n  } catch (err) {\n    return undefined;\n  }\n}\n"],"mappings":";AAAO,IAAK,eAAL,kBAAKA,kBAAL;AACL,EAAAA,cAAA,kBAAe;AACf,EAAAA,cAAA,WAAQ;AACR,EAAAA,cAAA,gBAAa;AACb,EAAAA,cAAA,eAAY;AACZ,EAAAA,cAAA,YAAS;AACT,EAAAA,cAAA,UAAO;AACP,EAAAA,cAAA,WAAQ;AACR,EAAAA,cAAA,YAAS;AACT,EAAAA,cAAA,aAAU;AATA,SAAAA;AAAA,GAAA;;;ACAL,IAAK,eAAL,kBAAKC,kBAAL;AACL,EAAAA,cAAA,UAAO;AACP,EAAAA,cAAA,SAAM;AACN,EAAAA,cAAA,aAAU;AACV,EAAAA,cAAA,YAAS;AAJC,SAAAA;AAAA,GAAA;;;ACAL,IAAK,sBAAL,kBAAKC,yBAAL;AACL,EAAAA,qBAAA,SAAM;AACN,EAAAA,qBAAA,UAAO;AACP,EAAAA,qBAAA,UAAO;AAHG,SAAAA;AAAA,GAAA;;;ACAZ,IAAM,eACJ;AAEF,IAAM,kBAAkB;AAkBjB,IAAM,aAAa,CAAC,YAAwC;AACjE,QAAM,UAAU,QAAQ,SAAS,YAAY;AAE7C,QAAM,UAA8B,CAAC;AAErC,aAAW,SAAS,SAAS;AAC3B,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI;AAEJ,YAAQ,KAAK;AAAA,MACX,QAAQ,eAAe;AAAA,MACvB;AAAA,MACA;AAAA,MACA,GAAI,iBAAiB,EAAE,cAAc;AAAA,MACrC,GAAI,gBAAgB,EAAE,aAAa;AAAA,MACnC,GAAI,mBAAmB,EAAE,gBAAgB;AAAA,IAC3C,CAAC;AAAA,EACH;AAEA,SAAO,mCAAS,OAAO;AACzB;AAEO,IAAM,wBAAwB,CACnC,sBAC2B;AAC3B,QAAM,UAAU,kBAAkB,SAAS,eAAe;AAE1D,QAAM,cAAsC,CAAC;AAE7C,aAAW,SAAS,SAAS;AAC3B,UAAM,CAAC,WAAW,UAAU,KAAK,QAAQ,cAAc,IAAI;AAE3D,gBAAY,KAAK;AAAA,MACf;AAAA,MACA,UAAU,SAAS,KAAK;AAAA,MACxB,QAAQ,OAAO,KAAK;AAAA,MACpB;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO;AACT;;;AClEO,IAAM,qBAAqB,CAAC,SAAiB,WAA2B;AAC7E,QAAM,UAAU,WAAW,OAAO;AAClC,QAAM,aAAa,QAAQ,QAAQ,SAAS,CAAC;AAE7C,QAAM,kBAAkB,aACpB,QAAQ,QAAQ,WAAW,SAAS,IACpC,QAAQ,SAAS;AAErB,SAAO,GAAG,QAAQ;AAAA,IAChB;AAAA,IACA,mBAAkB,yCAAY,UAAU;AAAA,EAC1C;AAAA,EAAM;AAAA,EAAW,QAAQ;AAAA,IACvB,mBAAkB,yCAAY,UAAU;AAAA,EAC1C;AACF;;;AChBA,SAAS,oBAAoB;AAC7B,SAAS,YAAY;AAEd,SAAS,eAEd,MACoB;AACpB,MAAI,EAAC,6BAAM,qBAAoB;AAC7B,WAAO;AAAA,EACT;AACA,MAAI;AACF,WAAO,aAAa,KAAK,KAAK,oBAAoB,IAAI,CAAC,EAAE,SAAS;AAAA,EACpE,SAAS,KAAP;AACA,WAAO;AAAA,EACT;AACF;","names":["ProjectTypes","UIFrameworks","PackageManagerTypes"]}