#!/usr/bin/env node
var __defProp = Object.defineProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __export = (target, all) => {
  for (var name3 in all)
    __defProp(target, name3, { get: all[name3], enumerable: true });
};

// src/cli.ts
import { Command as Command5 } from "commander";
import figlet from "figlet";

// src/components/update-warning-table/table.ts
import chalk2 from "chalk";
import center from "center-align";

// src/utils/spinner/index.ts
import ora from "ora";
var spinner = async (fn, message) => {
  const spinner2 = ora({
    color: "cyan",
    text: message
  }).start();
  const result = await fn();
  spinner2.stop();
  return result;
};
var spinner_default = spinner;

// src/utils/package/index.ts
import execa from "execa";
import { existsSync, pathExists, readFileSync, readJSON } from "fs-extra";
import globby from "globby";
import path from "path";
import preferredPM from "preferred-pm";
var getPackageJson = () => {
  if (!existsSync("package.json")) {
    console.error("\u274C `package.json` not found.");
    throw new Error("./package.json not found");
  }
  return JSON.parse(readFileSync("package.json", "utf8"));
};
var getDependencies = () => {
  const packageJson = getPackageJson();
  return Object.keys(packageJson.dependencies || {});
};
var getDependenciesWithVersion = () => {
  const packageJson = getPackageJson();
  return (packageJson == null ? void 0 : packageJson.dependencies) || {};
};
var getDevDependencies = () => {
  const packageJson = getPackageJson();
  return Object.keys(packageJson.devDependencies || {});
};
var getAllDependencies = () => {
  return [...getDependencies(), ...getDependencies()];
};
var getScripts = () => {
  const packageJson = getPackageJson();
  return (packageJson == null ? void 0 : packageJson.scripts) || {};
};
var getInstalledRefinePackages = async () => {
  var _a;
  try {
    const execution = await execa("npm", ["ls", "--depth=0", "--json"], {
      reject: false
    });
    const dependencies = ((_a = JSON.parse(execution.stdout)) == null ? void 0 : _a.dependencies) || {};
    const refineDependencies = Object.keys(dependencies).filter(
      (dependency) => dependency.startsWith("@refinedev") || dependency.startsWith("@pankod/refine-")
    );
    const normalize = [];
    for (const dependency of refineDependencies) {
      const version = dependencies[dependency].version;
      normalize.push({
        name: dependency,
        version
      });
    }
    return normalize;
  } catch (error) {
    return Promise.resolve(null);
  }
};
var getInstalledRefinePackagesFromNodeModules = async () => {
  const REFINE_PACKAGES = ["ably", "airtable", "antd", "appwrite", "chakra-ui", "codemod", "core", "devtools", "devtools-internal", "devtools-server", "devtools-shared", "devtools-ui", "graphql", "hasura", "inferencer", "kbar", "mantine", "medusa", "mui", "nestjs-query", "nestjsx-crud", "nextjs-router", "react-hook-form", "react-router", "react-table", "refine-ui", "remix-router", "rest", "shared", "simple-rest", "strapi", "strapi-v4", "supabase"];
  try {
    const packagesFromGlobbySearch = await globby("node_modules/@refinedev/*", {
      onlyDirectories: true
    });
    const packageDirsFromModules = REFINE_PACKAGES.flatMap((pkg) => {
      try {
        const pkgPath = __require.resolve(
          path.join("@refinedev", pkg, "package.json")
        );
        return [path.dirname(pkgPath)];
      } catch (err) {
        return [];
      }
    });
    const refinePackages = [];
    await Promise.all(
      [...packageDirsFromModules, ...packagesFromGlobbySearch].map(
        async (packageDir) => {
          const hasPackageJson = await pathExists(`${packageDir}/package.json`);
          if (hasPackageJson) {
            const packageJson = await readJSON(`${packageDir}/package.json`);
            refinePackages.push({
              name: packageJson.name,
              version: packageJson.version,
              path: packageDir
            });
          }
        }
      )
    );
    return refinePackages;
  } catch (err) {
    return [];
  }
};
var isPackageHaveRefineConfig = async (packagePath) => {
  return await pathExists(`${packagePath}/refine.config.js`);
};
var pmCommands = {
  npm: {
    add: ["install", "--save"],
    addDev: ["install", "--save-dev"],
    outdatedJson: ["outdated", "--json"],
    install: ["install"]
  },
  yarn: {
    add: ["add"],
    addDev: ["add", "-D"],
    outdatedJson: ["outdated", "--json"],
    install: ["install"]
  },
  pnpm: {
    add: ["add"],
    addDev: ["add", "-D"],
    outdatedJson: ["outdated", "--format", "json"],
    install: ["install"]
  },
  bun: {
    add: ["add"],
    addDev: ["add", "--dev"],
    outdatedJson: ["outdated", "--format", "json"],
    install: ["install"]
  }
};
var getPreferedPM = async () => {
  const pm = await spinner_default(
    () => preferredPM(process.cwd()),
    "Getting package manager..."
  );
  if (!pm) {
    throw new Error("Package manager not found.");
  }
  return pm;
};
var installPackages = async (packages, type = "all", successMessage = "All `Refine` packages updated  \u{1F389}") => {
  const pm = await getPreferedPM();
  try {
    const installCommand = type === "all" ? pmCommands[pm.name].install : pmCommands[pm.name].add;
    const execution = execa(pm.name, [...installCommand, ...packages], {
      stdio: "inherit"
    });
    execution.on("message", (message) => {
      console.log(message);
    });
    execution.on("error", (error) => {
      console.log(error);
    });
    execution.on("exit", (exitCode) => {
      if (exitCode === 0) {
        console.log(successMessage);
        return;
      }
      console.log(`Application exited with code ${exitCode}`);
    });
  } catch (error) {
    throw new Error(error);
  }
};
var installPackagesSync = async (packages) => {
  const pm = await getPreferedPM();
  try {
    const installCommand = pmCommands[pm.name].add;
    const execution = execa.sync(pm.name, [...installCommand, ...packages], {
      stdio: "inherit"
    });
    if (execution.failed || execution.exitCode !== 0) {
      throw new Error(execution.stderr);
    }
    return execution;
  } catch (error) {
    throw new Error(error);
  }
};
var parsePackageNameAndVersion = (str) => {
  const versionStartIndex = str.lastIndexOf("@");
  if (versionStartIndex <= 0) {
    return {
      name: str,
      version: null
    };
  }
  return {
    name: str.slice(0, versionStartIndex),
    version: str.slice(versionStartIndex + 1)
  };
};
var getRefineProjectId = () => {
  var _a;
  const packageJson = getPackageJson();
  return (_a = packageJson == null ? void 0 : packageJson.refine) == null ? void 0 : _a.projectId;
};
var isDevtoolsInstalled = async () => {
  const installedPackages = await getInstalledRefinePackagesFromNodeModules();
  return installedPackages.some((pkg) => pkg.name === "@refinedev/devtools");
};
var getNotInstalledPackages = (packages) => {
  const dependencies = getDependencies();
  return packages.filter((pkg) => !dependencies.includes(pkg));
};
var installMissingPackages = async (packages) => {
  console.log("\u{1F331} Checking dependencies...");
  const missingPackages = getNotInstalledPackages(packages);
  if (missingPackages.length > 0) {
    console.log(`\u{1F331} Installing ${missingPackages.join(", ")}`);
    await installPackagesSync(missingPackages);
    console.log("\u{1F389} Installation complete...");
  } else {
    console.log("\u{1F389} All required packages are already installed");
  }
};
var hasIncomatiblePackages = (packages) => {
  const allDependencies = getAllDependencies();
  const incompatiblePackages3 = packages.filter(
    (pkg) => allDependencies.includes(pkg)
  );
  if (incompatiblePackages3.length > 0) {
    console.log(
      `\u{1F6A8} This feature doesn't support ${incompatiblePackages3.join(
        ", "
      )} package.`
    );
    return true;
  }
  return false;
};
var getAllVersionsOfPackage = async (packageName) => {
  const pm = "npm";
  const { stdout, timedOut } = await execa(
    pm,
    ["view", packageName, "versions", "--json"],
    {
      reject: false,
      timeout: 25 * 1e3
    }
  );
  if (timedOut) {
    console.log("\u274C Timed out while checking for updates.");
    process.exit(1);
  }
  let result = [];
  try {
    result = JSON.parse(stdout);
    if (!result || "error" in result) {
      console.log("\u274C Something went wrong while checking for updates.");
      process.exit(1);
    }
  } catch (error) {
    console.log("\u274C Something went wrong while checking for updates.");
    process.exit(1);
  }
  return result;
};
var isInstalled = async (packageName) => {
  const installedPackages = await getInstalledRefinePackages();
  if (!installedPackages) {
    return false;
  }
  return installedPackages.some((pkg) => pkg.name === packageName);
};

// src/components/version-table/index.ts
import Table from "cli-table3";
import chalk from "chalk";

// src/utils/text/index.ts
var uppercaseFirstChar = (str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
};
var removeANSIColors = (str) => {
  return str.replace(
    // biome-ignore lint/suspicious/noControlCharactersInRegex: we want to remove invisible characters here.
    /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g,
    ""
  );
};

// src/components/version-table/index.ts
var columns = {
  name: "name",
  current: "current",
  wanted: "wanted",
  latest: "latest",
  changelog: "changelog"
};
var orderedColumns = [
  columns.name,
  columns.current,
  columns.wanted,
  columns.latest,
  columns.changelog
];
var getVersionTable = (packages = []) => {
  var _a;
  const tableHead = Object.keys((packages == null ? void 0 : packages[0]) || {});
  if (!packages || !tableHead.length)
    return { table: "", width: 0 };
  const terminalWidth = process.stdout.columns || 80;
  const nameColumnWidth = Math.max(...packages.map((row) => row.name.length)) + 2;
  const versionColumnWidth = 7 + 2;
  const bordersWidth = 6;
  const changelogColumnWidth = Math.min(
    35,
    terminalWidth - nameColumnWidth - versionColumnWidth * 3 - bordersWidth
  );
  const columnWidths = {
    name: nameColumnWidth,
    current: versionColumnWidth,
    wanted: versionColumnWidth,
    latest: versionColumnWidth,
    changelog: changelogColumnWidth
  };
  const table = new Table({
    head: orderedColumns,
    wordWrap: false,
    wrapOnWordBoundary: true,
    colWidths: orderedColumns.map((column) => columnWidths[column]),
    style: {
      head: ["blue"]
    }
  });
  const ellipsisFromCenter = (text, length) => {
    if (text.length > length) {
      const fitLength = length - 3;
      const start2 = text.slice(0, Math.floor(fitLength / 2));
      const end = text.slice(-Math.ceil(fitLength / 2));
      return `${start2}...${end}`;
    }
    return text;
  };
  packages.forEach((row) => {
    table.push(
      orderedColumns.map((column) => {
        const columnValue = row[column];
        if (!columnValue)
          return columnValue;
        if (column === "latest" || column === "wanted") {
          const installedVersion = parseVersions(row.current);
          const latestVersion = parseVersions(columnValue);
          const colors = getColorsByVersionDiffrence(
            installedVersion,
            latestVersion
          );
          const textMajor = chalk[colors.major](latestVersion.major);
          const textMinor = chalk[colors.minor](latestVersion.minor);
          const textPatch = chalk[colors.patch](latestVersion.patch);
          return `${textMajor}.${textMinor}.${textPatch}`;
        }
        if (column === "changelog") {
          return chalk.blueBright.underline(columnValue);
        }
        return columnValue;
      })
    );
  });
  const tableString = table.toString();
  const tableWidth = removeANSIColors(
    ((_a = tableString.split("\n")) == null ? void 0 : _a[0]) || ""
  ).length;
  return { table: tableString, width: tableWidth };
};
var parseVersions = (text) => {
  const versions = text.split(".");
  return {
    major: versions[0],
    minor: versions[1],
    patch: versions[2]
  };
};
var getColorsByVersionDiffrence = (installedVersion, nextVersion) => {
  const isMajorDiffrence = installedVersion.major.trim() !== nextVersion.major.trim();
  if (isMajorDiffrence)
    return {
      major: "red",
      minor: "red",
      patch: "red"
    };
  const isMinorDiffrence = installedVersion.minor.trim() !== nextVersion.minor.trim();
  if (isMinorDiffrence)
    return {
      major: "white",
      minor: "yellow",
      patch: "yellow"
    };
  const isPatchDiffrence = installedVersion.patch.trim() !== nextVersion.patch.trim();
  if (isPatchDiffrence)
    return {
      major: "white",
      minor: "white",
      patch: "green"
    };
  return {
    major: "white",
    minor: "white",
    patch: "white"
  };
};

// src/components/update-warning-table/table.ts
var printUpdateWarningTable = async (params) => {
  const data = params == null ? void 0 : params.data;
  const tableHead = Object.keys((data == null ? void 0 : data[0]) || {});
  if (!data || !tableHead.length)
    return;
  const { table, width } = getVersionTable(data);
  console.log();
  console.log(center("Update Available", width));
  console.log();
  console.log(
    `- ${chalk2.yellow(
      chalk2.bold("Current")
    )}: The version of the package that is currently installed`
  );
  console.log(
    `- ${chalk2.yellow(
      chalk2.bold("Wanted")
    )}: The maximum version of the package that satisfies the semver range specified in \`package.json\``
  );
  console.log(
    `- ${chalk2.yellow(
      chalk2.bold("Latest")
    )}: The latest version of the package available on npm`
  );
  console.log(table);
  console.log(
    center(
      `To update ${chalk2.bold("`Refine`")} packages with wanted version`,
      width
    )
  );
  console.log(
    center(
      ` Run the following command: ${chalk2.yellowBright(
        await getInstallCommand()
      )}`,
      width
    )
  );
  console.log();
};
var getInstallCommand = async () => {
  const fallbackCommand = "npx @refinedev/cli update";
  const dependencies = getDependencies();
  const scriptKeys = Object.keys(getScripts());
  const hasCli = dependencies.includes("@refinedev/cli");
  const hasScript = scriptKeys.includes("refine");
  if (!hasCli && !hasScript) {
    return fallbackCommand;
  }
  const pm = await getPreferedPM();
  if (hasScript) {
    return `${pm.name} run refine update`;
  }
  if (hasCli) {
    return "npx refine update";
  }
  return fallbackCommand;
};

// src/commands/check-updates/index.tsx
import semverDiff from "semver-diff";
import { maxSatisfying } from "semver";

// src/commands/check-updates/utils.ts
import execa2 from "execa";
var getOutdatedPackageList = async () => {
  const pm = "npm";
  const { stdout, timedOut } = await execa2(pm, pmCommands[pm].outdatedJson, {
    reject: false,
    timeout: 25 * 1e3
  });
  if (timedOut) {
    throw new Error("Timed out while checking for updates.");
  }
  if (!stdout)
    return null;
  return JSON.parse(stdout);
};

// src/commands/check-updates/index.tsx
var load = (program) => {
  return program.command("check-updates").description("Check all installed `Refine` packages are up to date").action(action);
};
var action = async () => {
  const packages = await spinner_default(isRefineUptoDate, "Checking for updates...");
  if (!packages.length) {
    console.log("All `Refine` packages are up to date \u{1F389}\n");
    return;
  }
  await printUpdateWarningTable({ data: packages });
};
var isRefineUptoDate = async () => {
  const refinePackages = await getOutdatedRefinePackages();
  return refinePackages;
};
var getOutdatedRefinePackages = async () => {
  const packages = await getOutdatedPackageList();
  if (!packages)
    return [];
  const list = [];
  Object.keys(packages).forEach((packageName) => {
    const dependency = packages[packageName];
    if (packageName.includes("@refinedev")) {
      list.push({
        ...dependency,
        name: packageName,
        changelog: packageName.replace(/@refinedev\//, "https://c.refine.dev/")
      });
    }
  });
  const filteredList = list.filter((item) => {
    const diff = semverDiff(item.current, item.latest);
    return !!diff;
  });
  return filteredList;
};
var getWantedWithPreferredWildcard = (packageName, versionWanted) => {
  const dependencies = getDependenciesWithVersion();
  const versionInPackageJson = dependencies[packageName];
  if (!versionInPackageJson) {
    return `^${versionWanted}`;
  }
  if (versionInPackageJson === "latest") {
    return "latest";
  }
  if (versionInPackageJson === "*") {
    return "*";
  }
  if ([">", "<", ">=", "<=", "||"].some(
    (char) => versionInPackageJson.includes(char)
  )) {
    return versionInPackageJson;
  }
  if (versionInPackageJson == null ? void 0 : versionInPackageJson.includes("x")) {
    return `${versionInPackageJson}`;
  }
  if (versionInPackageJson == null ? void 0 : versionInPackageJson.startsWith("~")) {
    return `~${versionWanted}`;
  }
  if (versionInPackageJson == null ? void 0 : versionInPackageJson.startsWith("^")) {
    return `^${versionWanted}`;
  }
  return versionWanted;
};
var getLatestMinorVersionOfPackage = async (packageName, version) => {
  const versionAll = await getAllVersionsOfPackage(packageName);
  const versionLatest = maxSatisfying(versionAll, `^${version}`);
  return versionLatest ?? version;
};
var check_updates_default = load;

// src/definitions/projectTypes.ts
var ProjectTypes = /* @__PURE__ */ ((ProjectTypes2) => {
  ProjectTypes2["REACT_SCRIPT"] = "react-scripts";
  ProjectTypes2["REMIX"] = "remix";
  ProjectTypes2["REMIX_VITE"] = "remix-vite";
  ProjectTypes2["REMIX_SPA"] = "remix-spa";
  ProjectTypes2["NEXTJS"] = "nextjs";
  ProjectTypes2["VITE"] = "vite";
  ProjectTypes2["CRACO"] = "craco";
  ProjectTypes2["PARCEL"] = "parcel";
  ProjectTypes2["UNKNOWN"] = "unknown";
  return ProjectTypes2;
})(ProjectTypes || {});

// src/definitions/uiFrameworks.ts
var UIFrameworks = /* @__PURE__ */ ((UIFrameworks2) => {
  UIFrameworks2["ANTD"] = "antd";
  UIFrameworks2["MUI"] = "mui";
  UIFrameworks2["MANTINE"] = "mantine";
  UIFrameworks2["CHAKRA"] = "chakra-ui";
  return UIFrameworks2;
})(UIFrameworks || {});

// src/definitions/package.ts
var PackageManagerTypes = /* @__PURE__ */ ((PackageManagerTypes2) => {
  PackageManagerTypes2["NPM"] = "npm";
  PackageManagerTypes2["YARN"] = "yarn";
  PackageManagerTypes2["PNPM"] = "pnpm";
  return PackageManagerTypes2;
})(PackageManagerTypes || {});

// src/utils/project/index.ts
var getProjectType = (platform) => {
  if (platform) {
    return platform;
  }
  let dependencies = [];
  let devDependencies = [];
  try {
    dependencies = getDependencies();
    devDependencies = getDevDependencies();
  } catch (error) {
  }
  if (dependencies.includes("@craco/craco") || devDependencies.includes("@craco/craco")) {
    return "craco" /* CRACO */;
  }
  if (dependencies.includes("react-scripts") || devDependencies.includes("react-scripts")) {
    return "react-scripts" /* REACT_SCRIPT */;
  }
  if (dependencies.includes("next") || devDependencies.includes("next")) {
    return "nextjs" /* NEXTJS */;
  }
  if (dependencies.includes("@remix-run/react") || devDependencies.includes("@remix-run/react")) {
    if (dependencies.includes("vite") || devDependencies.includes("vite")) {
      return "remix-vite" /* REMIX_VITE */;
    }
    return "remix" /* REMIX */;
  }
  if (dependencies.includes("vite") || devDependencies.includes("vite")) {
    return "vite" /* VITE */;
  }
  if (dependencies.includes("parcel") || devDependencies.includes("parcel")) {
    return "parcel" /* PARCEL */;
  }
  return "unknown" /* UNKNOWN */;
};
var getUIFramework = () => {
  const dependencies = getDependencies();
  if (dependencies.includes("@refinedev/antd")) {
    return "antd" /* ANTD */;
  }
  if (dependencies.includes("@refinedev/mui")) {
    return "mui" /* MUI */;
  }
  if (dependencies.includes("@refinedev/chakra-ui")) {
    return "chakra-ui" /* CHAKRA */;
  }
  if (dependencies.includes("@refinedev/mantine")) {
    return "mantine" /* MANTINE */;
  }
  return;
};
var getDevtoolsEnvKeyByProjectType = (projectType) => {
  switch (projectType) {
    case "react-scripts" /* REACT_SCRIPT */:
      return "REACT_APP_REFINE_DEVTOOLS_PORT";
    case "nextjs" /* NEXTJS */:
      return "NEXT_PUBLIC_REFINE_DEVTOOLS_PORT";
    case "vite" /* VITE */:
      return "VITE_REFINE_DEVTOOLS_PORT";
    default:
      return "REFINE_DEVTOOLS_PORT";
  }
};

// src/utils/resource/index.ts
import camelCase from "camelcase";
var getResourcePath = (projectType) => {
  switch (projectType) {
    case "nextjs" /* NEXTJS */:
      return {
        path: "src/components",
        alias: "../src/components"
      };
    case "remix" /* REMIX */:
    case "remix-vite" /* REMIX_VITE */:
    case "remix-spa" /* REMIX_SPA */:
      return {
        path: "app/components",
        alias: "~/components"
      };
  }
  return {
    path: "src/pages",
    alias: "pages"
  };
};
var getProviderPath = (projectType) => {
  switch (projectType) {
    case "nextjs" /* NEXTJS */:
      return {
        path: "src/providers",
        alias: "../src/providers"
      };
    case "remix" /* REMIX */:
    case "remix-vite" /* REMIX_VITE */:
    case "remix-spa" /* REMIX_SPA */:
      return {
        path: "app/providers",
        alias: "~/providers"
      };
  }
  return {
    path: "src/providers",
    alias: "providers"
  };
};
var getFilesPathByProject = (projectType) => {
  switch (projectType) {
    case "remix" /* REMIX */:
    case "remix-vite" /* REMIX_VITE */:
    case "remix-spa" /* REMIX_SPA */:
      return "./app";
    default:
      return "./src";
  }
};
var getComponentNameByResource = (resource) => {
  return camelCase(resource, {
    preserveConsecutiveUppercase: true,
    pascalCase: true
  });
};

// src/utils/compile/index.ts
import Handlebars from "handlebars";
import {
  readFileSync as readFileSync2,
  readdirSync,
  createFileSync,
  writeFileSync,
  unlinkSync
} from "fs-extra";
var compile = (filePath, params) => {
  const content = readFileSync2(filePath);
  Handlebars.registerHelper("ifIn", (elem, list, options) => {
    if (elem.includes(list)) {
      return options.fn(Handlebars);
    }
    return options.inverse(Handlebars);
  });
  Handlebars.registerHelper("formatInferencerComponent", (string) => {
    if (!string) {
      return;
    }
    switch (string) {
      case "chakra-ui":
        return "ChakraUI";
      default:
        return string.charAt(0).toUpperCase() + string.slice(1);
    }
  });
  Handlebars.registerHelper("capitalize", (string) => {
    if (!string) {
      return;
    }
    return string.charAt(0).toUpperCase() + string.slice(1);
  });
  Handlebars.registerHelper("getComponentNameByResource", (string) => {
    if (!string) {
      return;
    }
    return getComponentNameByResource(string);
  });
  const template = Handlebars.compile(content.toString());
  return template(params);
};
var compileDir = (dirPath, params) => {
  const files = readdirSync(dirPath, { recursive: true });
  files.forEach((file) => {
    if (typeof file !== "string" || !file.endsWith(".hbs"))
      return;
    const templateFilePath = `${dirPath}/${file}`;
    const compiledFilePath = `${dirPath}/${file.replace(".hbs", "")}`;
    createFileSync(compiledFilePath);
    writeFileSync(compiledFilePath, compile(templateFilePath, params));
    unlinkSync(templateFilePath);
  });
};

// src/commands/add/sub-commands/resource/create-resources.ts
import execa3 from "execa";
import {
  copySync,
  mkdirSync,
  moveSync,
  pathExistsSync,
  unlinkSync as unlinkSync2
} from "fs-extra";
import inquirer from "inquirer";
import { join } from "path";
import { plural } from "pluralize";
import temp from "temp";

// src/commands/add/sub-commands/resource/get-command-root-dir.ts
var getCommandRootDir = () => {
  return __dirname;
};

// src/commands/add/sub-commands/resource/create-resources.ts
var defaultActions = ["list", "create", "edit", "show"];
var createResources = async (params, resources) => {
  var _a;
  const destinationPath = (params == null ? void 0 : params.path) || getResourcePath(getProjectType()).path;
  let actions = params.actions || defaultActions.join(",");
  if (!resources.length) {
    const { name: name3, selectedActions } = await inquirer.prompt([
      {
        type: "input",
        name: "name",
        message: "Resource Name (users, products, orders etc.)",
        validate: (value) => {
          if (!value) {
            return "Resource Name is required";
          }
          return true;
        }
      },
      {
        type: "checkbox",
        name: "selectedActions",
        message: "Select Actions",
        choices: defaultActions,
        default: (_a = params == null ? void 0 : params.actions) == null ? void 0 : _a.split(",")
      }
    ]);
    resources = [name3];
    actions = selectedActions.join(",");
  }
  let isAtleastOneResourceCreated = false;
  resources.forEach((resourceName) => {
    const customActions = actions ? actions.split(",") : void 0;
    const resourceFolderName = plural(resourceName).toLowerCase();
    const resourcePath = join(
      process.cwd(),
      destinationPath,
      resourceFolderName
    );
    if (pathExistsSync(resourcePath)) {
      console.error(
        `\u274C Resource (${join(
          destinationPath,
          resourceFolderName
        )}) already exist!`
      );
      return;
    }
    isAtleastOneResourceCreated = true;
    const resource = uppercaseFirstChar(resourceName);
    const uiFramework = getUIFramework();
    const projectType = getProjectType();
    const isNextJs = projectType === "nextjs" /* NEXTJS */;
    const sourceDir = `${getCommandRootDir()}/../templates/resource/components`;
    const tempDir = generateTempDir();
    copySync(sourceDir, tempDir);
    const compileParams = {
      resourceName,
      resource,
      actions: customActions || defaultActions,
      uiFramework,
      isNextJs
    };
    compileDir(tempDir, compileParams);
    if (customActions) {
      defaultActions.forEach((action11) => {
        if (!customActions.includes(action11)) {
          unlinkSync2(`${tempDir}/${action11}.tsx`);
        }
      });
    }
    mkdirSync(destinationPath, { recursive: true });
    const destinationResourcePath = `${destinationPath}/${resourceFolderName}`;
    let moveSyncOptions = {};
    if (pathExistsSync(destinationResourcePath)) {
      moveSyncOptions = { overwrite: true };
    }
    moveSync(tempDir, destinationResourcePath, moveSyncOptions);
    temp.cleanupSync();
    if (isNextJs) {
      generateNextJsPages(
        resource,
        resourceFolderName,
        customActions || defaultActions
      );
    }
    const jscodeshiftExecutable = __require.resolve(".bin/jscodeshift");
    const { stderr } = execa3.sync(jscodeshiftExecutable, [
      "./",
      "--extensions=ts,tsx,js,jsx",
      "--parser=tsx",
      `--transform=${getCommandRootDir()}/../src/transformers/resource.ts`,
      "--ignore-pattern=.cache",
      "--ignore-pattern=node_modules",
      "--ignore-pattern=build",
      "--ignore-pattern=.next",
      "--ignore-pattern=dist",
      // pass custom params to transformer file
      `--__actions=${compileParams.actions}`,
      `--__pathAlias=${getResourcePath(getProjectType()).alias}`,
      `--__resourceFolderName=${resourceFolderName}`,
      `--__resource=${resource}`,
      `--__resourceName=${resourceName}`
    ]);
    if (stderr) {
      console.log(stderr);
    }
    console.log(
      `\u{1F389} Resource (${destinationResourcePath}) generated successfully!`
    );
  });
  if (isAtleastOneResourceCreated) {
    installInferencer();
  }
  return;
};
var generateTempDir = () => {
  temp.track();
  return temp.mkdirSync("resource");
};
var generateNextJsPages = (resource, resourceFolderName, actions) => {
  const resourcePageRootDirPath = join(
    process.cwd(),
    "src/app/",
    resourceFolderName
  );
  const actionPageRelativeDirPaths = {
    list: "/",
    create: "/create",
    edit: "/edit/[id]",
    show: "/show/[id]"
  };
  actions.forEach((action11) => {
    const actionPageRelativeDirPath = actionPageRelativeDirPaths[action11];
    const actionPageDirPath = join(
      resourcePageRootDirPath,
      actionPageRelativeDirPath
    );
    mkdirSync(actionPageDirPath, { recursive: true });
    const sourceFilePath = `${getCommandRootDir()}/../templates/resource/pages/next/${actionPageRelativeDirPath}/page.tsx.hbs`;
    const destFilePath = join(actionPageDirPath, "page.tsx.hbs");
    copySync(sourceFilePath, destFilePath);
  });
  const compileParams = { resource, resourceFolderName };
  compileDir(resourcePageRootDirPath, compileParams);
};
var installInferencer = async () => {
  console.log();
  const isInferencerInstalled = await spinner_default(
    () => isInstalled("@refinedev/inferencer"),
    "Checking if '@refinedev/inferencer' package is installed..."
  );
  if (!isInferencerInstalled) {
    console.log("\u{1F4E6} Installing '@refinedev/inferencer' package...");
    await installPackages(
      ["@refinedev/inferencer@latest"],
      "add",
      "\u2705 '@refinedev/inferencer' package installed successfully!"
    );
  }
};

// src/commands/create-resource/index.ts
var load2 = (program) => {
  const projectType = getProjectType();
  const { path: path5 } = getResourcePath(projectType);
  return program.command("create-resource").allowExcessArguments(true).description(
    `Create a new resource files (deprecated, please use "add resource" command)`
  ).option(
    "-a, --actions [actions]",
    "Only generate the specified actions. (ex: list,create,edit,show)",
    "list,create,edit,show"
  ).option("-p, --path [path]", "Path to generate the resource files", path5).action(action2);
};
var action2 = async (params, options) => {
  createResources(params, options.args);
};
var create_resource_default = load2;

// src/commands/runner/start/index.ts
import { Option } from "commander";

// src/update-notifier/index.tsx
import Conf from "conf";

// src/utils/encode/index.ts
var stringToBase64 = (str) => {
  if (typeof btoa !== "undefined") {
    return btoa(str);
  }
  return Buffer.from(str).toString("base64");
};

// src/utils/env/index.ts
import * as dotenv from "dotenv";
var refineEnv = {};
dotenv.config({ processEnv: refineEnv });
var envSearchMap = {
  development: /dev/i,
  production: /prod/i,
  test: /test|tst/i,
  "continuous-integration": /ci/i,
  "user-acceptance-testing": /uat/i,
  "system-integration-testing": /sit/i
};
var getNodeEnv = () => {
  const nodeEnv = process.env.NODE_ENV;
  if (!nodeEnv) {
    return "development";
  }
  let env = "custom";
  for (const [key, value] of Object.entries(envSearchMap)) {
    if (value.test(nodeEnv)) {
      env = key;
      break;
    }
  }
  return env;
};
var getEnvValue = (key) => {
  return process.env[key] || refineEnv[key];
};
var ENV = {
  NODE_ENV: getNodeEnv(),
  REFINE_NO_TELEMETRY: getEnvValue("REFINE_NO_TELEMETRY") || "false",
  UPDATE_NOTIFIER_IS_DISABLED: getEnvValue("UPDATE_NOTIFIER_IS_DISABLED") || "false",
  UPDATE_NOTIFIER_CACHE_TTL: getEnvValue("UPDATE_NOTIFIER_CACHE_TTL") || 1e3 * 60 * 60 * 24,
  REFINE_DEVTOOLS_PORT: getEnvValue("REFINE_DEVTOOLS_PORT")
};

// src/update-notifier/utils.ts
import chalk3 from "chalk";
var isPackagesCacheExpired = () => {
  const lastUpdated = store.get("lastUpdated");
  if (!lastUpdated)
    return true;
  const now = Date.now();
  const diff = now - lastUpdated;
  const cacheTTL = Number(ENV.UPDATE_NOTIFIER_CACHE_TTL);
  return diff >= cacheTTL;
};
var validateKey = async () => {
  const key = store.get("key");
  const newKey = await generateKeyFromPackages();
  if (newKey === null)
    return null;
  return key === newKey;
};
var generateKeyFromPackages = async () => {
  const packages = await getInstalledRefinePackages();
  if (!packages) {
    console.error(
      chalk3.red(
        "Something went wrong when trying to get installed `Refine` packages."
      )
    );
    return null;
  }
  const currentVersionsWithName = packages.map((p) => `${p.name}@${p.version}`);
  const hash = stringToBase64(currentVersionsWithName.toString());
  return hash;
};
var isUpdateNotifierDisabled = () => {
  return ENV.UPDATE_NOTIFIER_IS_DISABLED.toLocaleLowerCase() === "true";
};

// src/update-notifier/index.tsx
var STORE_NAME = "refine-update-notifier";
var store = new Conf({
  projectName: STORE_NAME,
  defaults: {
    key: "",
    lastUpdated: 0,
    packages: []
  }
});
var updateNotifier = async () => {
  if (isUpdateNotifierDisabled())
    return;
  const shouldUpdate = await shouldUpdatePackagesCache();
  if (shouldUpdate === null)
    return;
  if (shouldUpdate) {
    updatePackagesCache();
    return;
  }
  showWarning();
  updatePackagesCache();
};
var showWarning = async () => {
  const packages = store.get("packages");
  if (!(packages == null ? void 0 : packages.length))
    return;
  await printUpdateWarningTable({ data: packages });
  console.log("\n");
};
var shouldUpdatePackagesCache = async () => {
  const isKeyValid = await validateKey();
  const isExpired = isPackagesCacheExpired();
  if (isKeyValid === null)
    return null;
  if (isExpired || !isKeyValid)
    return true;
  return false;
};
var updatePackagesCache = async () => {
  try {
    const packages = await isRefineUptoDate();
    store.set("packages", packages);
    store.set("lastUpdated", Date.now());
    store.set("key", await generateKeyFromPackages());
    return packages;
  } catch (error) {
    store.set("packages", []);
    store.set("lastUpdated", Date.now());
    store.set("key", "");
    return null;
  }
};

// src/commands/runner/projectScripts.ts
function resolveBin(name3) {
  if (process.platform === "win32") {
    try {
      return __require.resolve(`.bin/${name3}.exe`);
    } catch {
    }
  }
  return __require.resolve(`.bin/${name3}`);
}
var projectScripts = {
  ["react-scripts" /* REACT_SCRIPT */]: {
    getDev: (args) => ["start", ...args],
    getStart: (args) => ["start", ...args],
    getBuild: (args) => ["build", ...args],
    getBin: () => resolveBin("react-scripts")
  },
  ["vite" /* VITE */]: {
    getDev: (args) => ["dev", ...args],
    getStart: (args) => ["preview", ...args],
    getBuild: (args) => ["build", ...args],
    getBin: () => resolveBin("vite")
  },
  ["nextjs" /* NEXTJS */]: {
    getDev: (args) => ["dev", ...args],
    getStart: (args) => ["start", ...args],
    getBuild: (args) => ["build", ...args],
    getBin: () => resolveBin("next")
  },
  ["remix" /* REMIX */]: {
    getDev: (args) => ["dev", ...args],
    getStart: (args) => {
      const hasArgs = args == null ? void 0 : args.length;
      if (hasArgs) {
        return args;
      }
      console.log();
      console.warn(
        "\u{1F6A8} Remix requires a path to the entry file. Please provide it as an argument to `refine start` command in package.json scripts"
      );
      console.warn("Refine will use `./build/index.js` as default");
      console.warn("Example: `refine start ./build/index.js`");
      console.log();
      return ["./build/index.js"];
    },
    getBuild: (args) => ["build", ...args],
    getBin: (type) => {
      return resolveBin(type === "start" ? "remix-serve" : "remix");
    }
  },
  ["remix-vite" /* REMIX_VITE */]: {
    getDev: (args) => ["vite:dev", ...args],
    getStart: (args) => {
      const hasArgs = args == null ? void 0 : args.length;
      if (hasArgs) {
        return args;
      }
      console.log();
      console.warn(
        "\u{1F6A8} Remix requires a path to the entry file. Please provide it as an argument to `refine start` command in package.json scripts"
      );
      console.warn("Refine will use `./build/server/index.js` as default");
      console.warn("Example: `refine start ./build/server/index.js`");
      console.log();
      return ["./build/server/index.js"];
    },
    getBuild: (args) => ["vite:build", ...args],
    getBin: (type) => {
      return resolveBin(type === "start" ? "remix-serve" : "remix");
    }
  },
  ["remix-spa" /* REMIX_SPA */]: {
    getDev: (args) => ["vite:dev", ...args],
    getStart: (args) => ["preview", ...args],
    getBuild: (args) => ["vite:build", ...args],
    getBin: (type) => {
      return resolveBin(type === "start" ? "vite" : "remix");
    }
  },
  ["craco" /* CRACO */]: {
    getDev: (args) => ["start", ...args],
    getStart: (args) => ["start", ...args],
    getBuild: (args) => ["build", ...args],
    getBin: () => resolveBin("craco")
  },
  ["parcel" /* PARCEL */]: {
    getDev: (args) => ["start", ...args],
    getStart: (args) => ["start", ...args],
    getBuild: (args) => ["build", ...args],
    getBin: () => resolveBin("parcel")
  },
  ["unknown" /* UNKNOWN */]: {
    getDev: (args) => [...args],
    getStart: (args) => [...args],
    getBuild: (args) => [...args],
    getBin: () => {
      return "unknown";
    }
  }
};

// src/commands/runner/runScript.ts
import execa4 from "execa";
var runScript = async (binPath, args, env = {}) => {
  var _a, _b;
  if (binPath === "unknown") {
    const supportedProjectTypes = Object.values(ProjectTypes).filter((v) => v !== "unknown").join(", ");
    console.error(
      `We couldn't find executable for your project. Supported executables are ${supportedProjectTypes}.
Please use your own script directly. If you think this is an issue, please report it at: https://github.com/refinedev/refine/issues`
    );
    return;
  }
  const execution = execa4(binPath, args, {
    stdio: "pipe",
    windowsHide: false,
    env: {
      FORCE_COLOR: "true",
      REFINE_NO_TELEMETRY: ENV.REFINE_NO_TELEMETRY,
      ...env,
      ...process.env
    }
  });
  (_a = execution.stdout) == null ? void 0 : _a.pipe(process.stdout);
  (_b = execution.stderr) == null ? void 0 : _b.pipe(process.stderr);
  return await execution;
};

// src/commands/runner/utils/index.ts
var getRunnerDescription = (runner) => {
  let projectType = getProjectType();
  let command = [];
  switch (runner) {
    case "dev":
      command = projectScripts[projectType].getDev([""]);
      break;
    case "start":
      command = projectScripts[projectType].getStart([""]);
      break;
    case "build":
      command = projectScripts[projectType].getBuild([""]);
      break;
  }
  if (runner === "start") {
    switch (projectType) {
      case "remix" /* REMIX */:
      case "remix-vite" /* REMIX_VITE */:
        projectType = "remix-serve";
        break;
      case "remix-spa" /* REMIX_SPA */:
        projectType = "vite" /* VITE */;
        break;
    }
  }
  return `It runs: \`${projectType} ${command.join(
    " "
  )}\`. Also accepts all the arguments \`${projectType}\` accepts.`;
};
var getPlatformOptionDescription = () => {
  return `Platform to run command on. 
ex: ${Object.values(ProjectTypes).join(
    ", "
  )}`;
};

// src/commands/runner/start/index.ts
var start = (program) => {
  return program.command("start").description(getRunnerDescription("start")).allowUnknownOption(true).addOption(
    new Option(
      "-p, --platform <platform>",
      getPlatformOptionDescription()
    ).choices(
      Object.values(ProjectTypes).filter(
        (type) => type !== "unknown" /* UNKNOWN */
      )
    )
  ).argument("[args...]").action(action3);
};
var action3 = async (args, { platform }) => {
  const projectType = getProjectType(platform);
  const binPath = projectScripts[projectType].getBin("start");
  const command = projectScripts[projectType].getStart(args);
  await updateNotifier();
  runScript(binPath, command);
};
var start_default = start;

// src/commands/runner/dev/index.ts
import { Option as Option2 } from "commander";

// src/commands/devtools/index.ts
import { server } from "@refinedev/devtools-server";

// src/transformers/add-devtools-component.ts
import execa5 from "execa";

// src/utils/swizzle/prettierFormat.ts
import { format, resolveConfig } from "prettier";
var prettierFormat = async (code) => {
  try {
    const prettierConfig = await resolveConfig(process.cwd());
    return format(code, {
      ...prettierConfig ?? {},
      parser: "typescript"
    });
  } catch (err) {
    return code;
  }
};

// src/transformers/add-devtools-component.ts
var addDevtoolsComponent = async () => {
  const jscodeshiftExecutable = __require.resolve(".bin/jscodeshift");
  const { stderr } = execa5.sync(jscodeshiftExecutable, [
    "./",
    "--extensions=ts,tsx,js,jsx",
    "--parser=tsx",
    `--transform=${__dirname}/../src/transformers/add-devtools-component.ts`,
    "--ignore-pattern=.cache",
    "--ignore-pattern=node_modules",
    "--ignore-pattern=build",
    "--ignore-pattern=.next",
    "--ignore-pattern=dist"
  ]);
  if (stderr) {
    console.log(stderr);
  }
};

// src/utils/refine/index.ts
var hasDefaultScript = () => {
  const packageJson = getPackageJson();
  const scripts = packageJson.scripts || {};
  const isDefault = ((scripts == null ? void 0 : scripts.dev) || "").match(/refine dev(\s|$|;){1}/) !== null;
  return {
    dev: isDefault
  };
};

// src/commands/devtools/index.ts
import boxen from "boxen";
import cardinal from "cardinal";
import chalk4 from "chalk";
import { Argument } from "commander";
import dedent from "dedent";
import semver from "semver";
var commands = ["start", "init"];
var defaultCommand = "start";
var minRefineCoreVersionForDevtools = "4.42.0";
var load3 = (program) => {
  return program.command("devtools").description(
    "Start or install Refine Devtools server; it starts on port 5001."
  ).addArgument(
    new Argument("[command]", "devtools related commands").choices(commands).default(defaultCommand)
  ).addHelpText(
    "after",
    `
Commands:
    start     Start Refine Devtools server
    init      Install Refine Devtools client and adds it to your project
`
  ).action(action4);
};
var action4 = async (command) => {
  switch (command) {
    case "start":
      devtoolsRunner();
      return;
    case "init":
      devtoolsInstaller();
      return;
  }
};
var devtoolsInstaller = async () => {
  var _a;
  const corePackage = await getRefineCorePackage();
  const isInstalled2 = await spinner_default(
    isDevtoolsInstalled,
    "Checking if devtools is installed..."
  );
  if (isInstalled2) {
    console.log("\u{1F389} Refine Devtools is already installed");
    return;
  }
  if (corePackage && await validateCorePackageIsNotDeprecated({ pkg: corePackage })) {
    return;
  }
  console.log("\u{1F331} Installing Refine Devtools...");
  const packagesToInstall = ["@refinedev/devtools@latest"];
  if (!corePackage || semver.lt(corePackage.version, minRefineCoreVersionForDevtools)) {
    packagesToInstall.push("@refinedev/core@latest");
    console.log("\u{1F331} Refine core package is being updated for devtools...");
  }
  await installPackagesSync(packagesToInstall);
  console.log("");
  console.log("");
  console.log("\u{1F331} Adding devtools component to your project....");
  await addDevtoolsComponent();
  console.log(
    "\u2705 Refine Devtools package and components added to your project"
  );
  if (packagesToInstall.includes("@refinedev/core@latest")) {
    const updatedCorePackage = await getRefineCorePackage();
    console.log(
      `\u2705 Refine core package updated from ${(corePackage == null ? void 0 : corePackage.version) ?? "unknown"} to ${(updatedCorePackage == null ? void 0 : updatedCorePackage.version) ?? "unknown"}`
    );
    console.log(
      `   Changelog: ${chalk4.underline.blueBright(
        `https://c.refine.dev/core#${(corePackage == null ? void 0 : corePackage.version.replaceAll(".", "")) ?? ""}`
      )}`
    );
  }
  console.log("");
  const { dev: dev2 } = hasDefaultScript();
  if (dev2) {
    console.log(
      `\u{1F64C} You're good to go. "npm run dev" will automatically starts the devtools server.`
    );
    console.log(
      `\u{1F449} You can also start the devtools server manually by running "refine devtools start"`
    );
    return;
  }
  if (!dev2) {
    const scriptDev = (_a = getPackageJson().scripts) == null ? void 0 : _a.dev;
    console.log(
      `\u{1F6A8} Your have modified the "dev" script in your package.json. Because of that, "npm run dev" will not start the devtools server automatically.`
    );
    console.log(`\u{1F449} You can append "refine devtools" to "dev" script`);
    console.log(
      `\u{1F449} You can start the devtools server manually by running "refine devtools"`
    );
    console.log("");
    console.log(
      boxen(
        cardinal.highlight(
          dedent(`
                {
                    "scripts": {
                        "dev": "${scriptDev} & refine devtools",
                        "refine": "refine"
                    }
                }  
        `)
        ),
        {
          padding: 1,
          title: "package.json",
          dimBorder: true,
          borderColor: "blueBright",
          borderStyle: "round"
        }
      )
    );
  }
};
var devtoolsRunner = async ({
  exitOnError = true
} = {}) => {
  const corePackage = await getRefineCorePackage();
  if (corePackage) {
    if (await validateCorePackageIsNotDeprecated({ pkg: corePackage })) {
      return;
    }
    if (semver.lt(corePackage.version, minRefineCoreVersionForDevtools)) {
      console.log(
        `\u{1F6A8} You're using an old version of Refine(${corePackage.version}). Refine version should be @4.42.0 or higher to use devtools.`
      );
      const pm = await getPreferedPM();
      console.log(
        `\u{1F449} You can update @refinedev/core package by running "${pm.name} run refine update"`
      );
      return;
    }
  }
  server({
    onError: () => {
      if (exitOnError) {
        process.exit(1);
      }
    }
  }).catch((e) => {
  });
};
var getRefineCorePackage = async () => {
  const installedRefinePackages = await getInstalledRefinePackagesFromNodeModules();
  const corePackage = installedRefinePackages == null ? void 0 : installedRefinePackages.find(
    (pkg) => pkg.name === "@refinedev/core" || pkg.name === "@pankod/refine-core"
  );
  if (!corePackage) {
    return void 0;
  }
  return corePackage;
};
var validateCorePackageIsNotDeprecated = async ({
  pkg
}) => {
  if (pkg.name === "@pankod/refine-core" || semver.lt(pkg.version, "4.0.0")) {
    console.log(
      `\u{1F6A8} You're using an old version of Refine(${pkg.version}). Refine version should be @4.42.0 or higher to use devtools.`
    );
    console.log("You can follow migration guide to update Refine.");
    console.log(
      chalk4.blue("https://refine.dev/docs/migration-guide/3x-to-4x/")
    );
    return true;
  }
  return false;
};
var devtools_default = load3;

// src/commands/runner/dev/index.ts
var dev = (program) => {
  return program.command("dev").description(getRunnerDescription("dev")).allowUnknownOption(true).addOption(
    new Option2(
      "-p, --platform <platform>",
      getPlatformOptionDescription()
    ).choices(
      Object.values(ProjectTypes).filter(
        (type) => type !== "unknown" /* UNKNOWN */
      )
    )
  ).addOption(
    new Option2(
      "-d, --devtools <devtools>",
      "Start Refine Devtools server"
    ).default("true", "true if devtools is installed")
  ).argument("[args...]").action(action5);
};
var action5 = async (args, { platform, ...params }) => {
  const projectType = getProjectType(platform);
  const binPath = projectScripts[projectType].getBin("dev");
  const command = projectScripts[projectType].getDev(args);
  await updateNotifier();
  const devtoolsPortEnvKey = getDevtoolsEnvKeyByProjectType(projectType);
  const devtoolsDefault = await isDevtoolsInstalled();
  const devtools = params.devtools === "false" ? false : devtoolsDefault;
  if (devtools) {
    devtoolsRunner({ exitOnError: false });
  }
  const envWithDevtoolsPort = devtools && ENV.REFINE_DEVTOOLS_PORT ? { [devtoolsPortEnvKey]: ENV.REFINE_DEVTOOLS_PORT } : void 0;
  runScript(binPath, command, envWithDevtoolsPort);
};
var dev_default = dev;

// src/commands/runner/build/index.ts
import { Option as Option3 } from "commander";
var build = (program) => {
  return program.command("build").description(getRunnerDescription("build")).allowUnknownOption(true).addOption(
    new Option3(
      "-p, --platform <platform>",
      getPlatformOptionDescription()
    ).choices(
      Object.values(ProjectTypes).filter(
        (type) => type !== "unknown" /* UNKNOWN */
      )
    )
  ).argument("[args...]").action(action6);
};
var action6 = async (args, { platform }) => {
  const projectType = getProjectType(platform);
  const binPath = projectScripts[projectType].getBin("build");
  const command = projectScripts[projectType].getBuild(args);
  await updateNotifier();
  try {
    await runScript(binPath, command);
  } catch (error) {
    process.exit(1);
  }
};
var build_default = build;

// src/commands/runner/run/index.ts
import chalk5 from "chalk";
var run = (program) => {
  return program.command("run").description(
    "Runs a defined package script. If no `command` is provided, it will list the available scripts"
  ).allowUnknownOption(true).argument("[command] [args...]").action(action7);
};
var action7 = async (args) => {
  const [script, ...restArgs] = args;
  const scriptsInPackage = getScripts();
  if (!script) {
    console.log(`Available via ${chalk5.blue("`refine run`")}:
`);
    for (const [key, value] of Object.entries(scriptsInPackage)) {
      console.log(`  ${key}`);
      console.log(`    ${chalk5.dim(value)}`);
      console.log();
    }
    return;
  }
  const isDefinedScript = Object.keys(scriptsInPackage).includes(script);
  if (!isDefinedScript) {
    const binPath = `${process.cwd()}/node_modules/.bin/${script}`;
    runScript(binPath, restArgs);
    return;
  }
  const pm = await getPreferedPM();
  runScript(pm.name, ["run", script, ...restArgs]);
};
var run_default = run;

// src/commands/swizzle/index.tsx
import path4 from "path";
import chalk9 from "chalk";
import inquirer3 from "inquirer";
import inquirerAutoCompletePrompt from "inquirer-autocomplete-prompt";
import { ensureFile, pathExists as pathExists2, readFile, writeFile } from "fs-extra";

// src/utils/swizzle/index.ts
import path3 from "path";

// src/utils/swizzle/provideCliHelpers.ts
import path2 from "path";

// src/index.ts
var src_exports = {};
__export(src_exports, {
  PackageManagerTypes: () => PackageManagerTypes,
  ProjectTypes: () => ProjectTypes,
  UIFrameworks: () => UIFrameworks,
  appendAfterImports: () => appendAfterImports,
  getFileContent: () => getFileContent,
  getImports: () => getImports,
  getNameChangeInImport: () => getNameChangeInImport
});

// src/utils/swizzle/import.ts
var packageRegex = /import(?:\s+(type))?\s*(?:([^\s\{\},]+)\s*(?:,\s*)?)?(\{[^}]+\})?\s*(?:\*\s*as\s+([^\s\{\}]+)\s*)?from\s*['"]([^'"]+)['"];?/g;
var nameChangeRegex = /((?:\w|\s|_)*)( as )((?:\w|\s|_)*)( |,)?/g;
var getImports = (content) => {
  const matches = content.matchAll(packageRegex);
  const imports = [];
  for (const match of matches) {
    const [
      statement,
      typePrefix,
      defaultImport,
      namedImports,
      namespaceImport,
      importPath
    ] = match;
    imports.push({
      isType: typePrefix === "type",
      statement,
      importPath,
      ...defaultImport && { defaultImport },
      ...namedImports && { namedImports },
      ...namespaceImport && { namespaceImport }
    });
  }
  return imports == null ? void 0 : imports.filter(Boolean);
};
var getNameChangeInImport = (namedImportString) => {
  const matches = namedImportString.matchAll(nameChangeRegex);
  const nameChanges = [];
  for (const match of matches) {
    const [statement, fromName, _as, toName, afterCharacter] = match;
    nameChanges.push({
      statement,
      fromName: fromName.trim(),
      toName: toName.trim(),
      afterCharacter
    });
  }
  return nameChanges;
};
var getContentBeforeImport = (content, importMatch) => {
  var _a;
  const contentBeforeImport = content.substring(
    0,
    content.indexOf(importMatch.statement)
  );
  const lastImportStatement = getImports(contentBeforeImport).pop();
  if (!lastImportStatement) {
    return contentBeforeImport;
  }
  const contentBetweenImports = contentBeforeImport.substring(
    contentBeforeImport.indexOf(lastImportStatement == null ? void 0 : lastImportStatement.statement) + ((_a = lastImportStatement == null ? void 0 : lastImportStatement.statement) == null ? void 0 : _a.length)
  );
  return contentBetweenImports;
};
var isImportHasBeforeContent = (content, importMatch) => {
  const contentBeforeImport = importMatch ? getContentBeforeImport(content, importMatch) : "";
  return !!contentBeforeImport.trim();
};
var IMPORT_ORDER = ["react", "@refinedev/core", "@refinedev/"];
var reorderImports = (content) => {
  var _a;
  let newContent = content;
  const allImports = getImports(content);
  const allModuleImports = allImports.filter(
    (importMatch) => !importMatch.isType
  );
  const typeImports = allImports.filter((importMatch) => importMatch.isType);
  const importsWithBeforeContent = [];
  const importsWithoutBeforeContent = [];
  typeImports.forEach((importMatch) => {
    newContent = newContent.replace(`${importMatch.statement}
`, "");
  });
  allModuleImports.forEach((importMatch) => {
    if (isImportHasBeforeContent(newContent, importMatch)) {
      importsWithBeforeContent.push(importMatch);
    } else {
      importsWithoutBeforeContent.push(importMatch);
    }
  });
  const insertionPoint = newContent.indexOf(
    (_a = importsWithoutBeforeContent == null ? void 0 : importsWithoutBeforeContent[0]) == null ? void 0 : _a.statement
  );
  importsWithoutBeforeContent.forEach((importMatch) => {
    newContent = newContent.replace(importMatch.statement, "");
  });
  const importsByPackage = importsWithoutBeforeContent.reduce(
    (acc, importMatch) => {
      const { importPath } = importMatch;
      if (acc[importPath]) {
        acc[importPath].push(importMatch);
      } else {
        acc[importPath] = [importMatch];
      }
      return acc;
    },
    {}
  );
  const mergedImports = Object.entries(importsByPackage).map(
    ([importPath, importMatches]) => {
      const defaultImport = importMatches.find(
        (importMatch) => importMatch.defaultImport
      );
      const namespaceImport = importMatches.find(
        (importMatch) => importMatch.namespaceImport
      );
      const namedImports = importMatches.filter((importMatch) => importMatch.namedImports).map((importMatch) => {
        const namedImports2 = (importMatch.namedImports ?? "").replace(/{|}/g, "").trim().split(",").map((namedImport) => namedImport.trim());
        return namedImports2.filter(Boolean).join(", ");
      }).join(", ");
      let importLine = "";
      if (namespaceImport) {
        importLine += `${namespaceImport.statement}
`;
      }
      if (defaultImport || namedImports) {
        if (defaultImport && namedImports) {
          importLine += `import ${defaultImport.defaultImport}, { ${namedImports} } from "${importMatches[0].importPath}";
`;
        } else if (defaultImport) {
          importLine += `import ${defaultImport.defaultImport} from "${importMatches[0].importPath}";
`;
        } else {
          importLine += `import { ${namedImports} } from "${importMatches[0].importPath}";
`;
        }
      }
      return [importPath, importLine];
    }
  );
  const sortedImports = [...mergedImports].sort(
    ([aImportPath], [bImportPath]) => {
      const aImportOrderIndex = IMPORT_ORDER.findIndex(
        (order) => aImportPath.includes(order)
      );
      const bImportOrderIndex = IMPORT_ORDER.findIndex(
        (order) => bImportPath.includes(order)
      );
      if (aImportOrderIndex === bImportOrderIndex) {
        return aImportPath.localeCompare(bImportPath);
      }
      if (aImportOrderIndex === -1) {
        return 1;
      }
      if (bImportOrderIndex === -1) {
        return -1;
      }
      return aImportOrderIndex - bImportOrderIndex;
    }
  );
  const joinedModuleImports = sortedImports.map(([, importLine]) => importLine).join("");
  const joinedTypeImports = [
    ...typeImports.map((importMatch) => importMatch.statement),
    ""
  ].join("\n");
  newContent = newContent.substring(0, insertionPoint) + joinedModuleImports + joinedTypeImports + newContent.substring(insertionPoint);
  return newContent;
};

// src/utils/swizzle/appendAfterImports.ts
var appendAfterImports = (content, append) => {
  const imports = getImports(content);
  const lastImport = imports[imports.length - 1];
  const lastImportIndex = lastImport ? content.indexOf(lastImport.statement) : content.length - 1;
  return `${content.slice(
    0,
    lastImportIndex + (lastImport == null ? void 0 : lastImport.statement.length)
  )}
${append}
${content.slice(
    lastImportIndex + (lastImport == null ? void 0 : lastImport.statement.length)
  )}`;
};

// src/utils/swizzle/getFileContent.ts
import { readFileSync as readFileSync3 } from "fs-extra";
import { join as join2 } from "path";
function getFileContent(path5) {
  if (!(this == null ? void 0 : this.absolutePackageDir)) {
    return void 0;
  }
  try {
    return readFileSync3(join2(this.absolutePackageDir, path5)).toString();
  } catch (err) {
    return void 0;
  }
}

// src/utils/swizzle/provideCliHelpers.ts
var Module = __require("module");
var originalRequire = Module.prototype.require;
var provideCliHelpers = (packagePath, isAbsolute) => {
  Module.prototype.require = function(...args) {
    if (args[0] === "@refinedev/cli") {
      return {
        ...src_exports,
        getFileContent: (filePath) => {
          return getFileContent.call(
            {
              absolutePackageDir: isAbsolute ? packagePath : path2.join(process.cwd(), packagePath)
            },
            filePath
          );
        }
      };
    }
    return originalRequire.apply(this, args);
  };
};

// src/utils/swizzle/index.ts
var getRefineConfig = async (packagePath, isAbsolute) => {
  try {
    provideCliHelpers(packagePath, isAbsolute);
    const config2 = __require(path3.join(
      isAbsolute ? packagePath : path3.join(process.cwd(), packagePath),
      "refine.config.js"
    ));
    return config2;
  } catch (error) {
    return void 0;
  }
};

// src/components/swizzle-message/index.tsx
import dedent2 from "dedent";

// src/utils/swizzle/codes.ts
var SWIZZLE_CODES = {
  SUCCESS: "SUCCESS",
  UNKNOWN_ERROR: "UNKNOWN_ERROR",
  SOURCE_PATH_NOT_FOUND: "SOURCE_PATH_NOT_FOUND",
  TARGET_PATH_NOT_FOUND: "TARGET_PATH_NOT_FOUND",
  SOURCE_PATH_NOT_A_FILE: "SOURCE_PATH_NOT_A_FILE",
  TARGET_ALREADY_EXISTS: "TARGET_ALREADY_EXISTS"
};

// src/components/swizzle-message/index.tsx
import chalk7 from "chalk";

// src/utils/swizzle/renderCodeMarkdown.ts
import chalk6 from "chalk";
import cardinal2 from "cardinal";
import boxen2 from "boxen";
var getCodeData = (content) => {
  const titleRegexp = /^(?:\/\/\s?title:\s?)(.*?)\n/g;
  const [commentLine, titleMatch] = titleRegexp.exec(content) ?? [];
  if (titleMatch) {
    const title = titleMatch.trim();
    const code = content.replace(commentLine || "", "");
    return { title, code };
  }
  return { code: content };
};
var renderCodeMarkdown = (content) => {
  const { title, code: rawCode } = getCodeData(content);
  let highlighted = "";
  try {
    const code = cardinal2.highlight(rawCode, {
      jsx: true
    });
    highlighted = code;
  } catch (err) {
    highlighted = rawCode;
  }
  const boxed = boxen2(highlighted, {
    padding: 1,
    margin: 0,
    borderStyle: "round",
    borderColor: "gray",
    titleAlignment: "left",
    title: title ? chalk6.bold(title) : void 0
  });
  return boxed;
};

// src/utils/marked-terminal-renderer/index.ts
import { marked } from "marked";
import TerminalRenderer from "marked-terminal";
var markedTerminalRenderer = (markdown) => {
  return marked(markdown, {
    renderer: new TerminalRenderer({ code: renderCodeMarkdown })
  });
};

// src/components/swizzle-message/index.tsx
var printSwizzleMessage = ({
  label,
  files,
  message = "**`Warning:`** You should use the component where you want to use it."
}) => {
  const errors = files.filter(
    ([, statusCode]) => Object.values(SWIZZLE_CODES).filter((code) => code !== SWIZZLE_CODES.SUCCESS).includes(statusCode)
  );
  let status = "success";
  switch (errors.length) {
    case 0:
      status = "success";
      break;
    case files.length:
      status = "error";
      break;
    default:
      status = "warning";
      break;
  }
  const clearFilePath = (filePath) => {
    const relative2 = filePath == null ? void 0 : filePath.replace(process.cwd(), "");
    if (relative2 == null ? void 0 : relative2.startsWith("/")) {
      return relative2.slice(1);
    }
    if (relative2 == null ? void 0 : relative2.startsWith("./")) {
      return relative2.slice(2);
    }
    return relative2;
  };
  const printStatusMessage = () => {
    switch (status) {
      case "success":
        console.log(
          chalk7.blueBright(`Successfully swizzled ${chalk7.bold(label)}`)
        );
        return;
      case "warning":
        console.log(
          chalk7.yellowBright(
            `Swizzle completed with errors for ${chalk7.bold(label)}`
          )
        );
        return;
      case "error":
        console.log(chalk7.redBright(`Swizzle failed for ${chalk7.bold(label)}`));
        return;
      default:
        return;
    }
  };
  const printFiles = () => {
    const chalks = [];
    chalks.push(chalk7.dim(`File${files.length > 1 ? "s" : ""} created:`));
    chalks.push(
      files.map(([targetPath, statusCode]) => {
        if (statusCode === SWIZZLE_CODES.SUCCESS) {
          return chalk7.cyanBright.dim(` - ${clearFilePath(targetPath)}`);
        }
        if (statusCode === SWIZZLE_CODES.TARGET_ALREADY_EXISTS) {
          return chalk7.cyanBright.dim(
            ` - ${chalk7.yellowBright.bold(
              "[FILE_ALREADY_EXISTS] "
            )}${clearFilePath(targetPath)}`
          );
        }
        if (statusCode === SWIZZLE_CODES.SOURCE_PATH_NOT_A_FILE) {
          return chalk7.cyanBright.dim(
            ` - ${chalk7.yellowBright.bold(
              "[SOURCE NOT FOUND] "
            )}${clearFilePath(targetPath)}`
          );
        }
        return chalk7.cyanBright.dim(
          ` - ${chalk7.yellowBright.bold(`[${statusCode}]`)}${clearFilePath(
            targetPath
          )}`
        );
      }).join("\n")
    );
    console.log(chalks.join("\n"));
  };
  const printSwizzleMessage2 = () => {
    if (message && status !== "error") {
      console.log(markedTerminalRenderer(dedent2(`
${message}`)));
    }
  };
  console.log("");
  printStatusMessage();
  printFiles();
  console.log("");
  printSwizzleMessage2();
};

// src/utils/swizzle/parseSwizzleBlocks.ts
var parseSwizzleBlocks = (content) => {
  const regex = /(\/\/|\/\*)(\s?)swizzle-remove-start([\s\S]*?)(\/\/|\/\*)(\s?)swizzle-remove-end(\s*)(\*\/)?/g;
  return content.replace(regex, "");
};

// src/commands/swizzle/index.tsx
import boxen3 from "boxen";

// src/utils/swizzle/getPathPrefix.ts
var getPathPrefix = () => {
  let projectType = void 0;
  try {
    projectType = getProjectType();
  } catch (error) {
    projectType = void 0;
  }
  const pathPrefix = getFilesPathByProject(projectType);
  return pathPrefix;
};

// src/commands/swizzle/install-required-packages/utils.ts
import inquirer2 from "inquirer";
import chalk8 from "chalk";
var promptForPackageInstallation = async (requiredPackages3) => {
  const message = "This component requires following packages to be installed:\n".concat(requiredPackages3.map((pkg) => ` - ${pkg}`).join("\n")).concat("\nDo you want to install them?");
  const { installRequiredPackages: installRequiredPackages2 } = await inquirer2.prompt([
    {
      type: "confirm",
      name: "installRequiredPackages",
      default: true,
      message
    }
  ]);
  return installRequiredPackages2;
};
var displayManualInstallationCommand = async (requiredPackages3) => {
  const pm = await getPreferedPM();
  const pmCommand = pmCommands[pm.name].add.join(" ");
  const packages = requiredPackages3.join(" ");
  const command = `${pm.name} ${pmCommand} ${packages}`;
  console.log("\nYou can install them manually by running this command:");
  console.log(chalk8.bold.blueBright(command));
};

// src/commands/swizzle/install-required-packages/index.ts
var installRequiredPackages = async (requiredPackages3) => {
  const installRequiredPackages2 = await promptForPackageInstallation(requiredPackages3);
  if (!installRequiredPackages2) {
    await displayManualInstallationCommand(requiredPackages3);
  } else {
    await installPackages(requiredPackages3);
  }
};

// src/commands/swizzle/index.tsx
var swizzle = (program) => {
  return program.command("swizzle").description(
    `Export a component or a function from ${chalk9.bold(
      "Refine"
    )} packages to customize it in your project`
  ).action(action8);
};
var getAutocompleteSource = (rawList) => (_answers, input = "") => {
  const filtered = rawList.filter(
    (el) => {
      var _a;
      return el.label.toLowerCase().includes(input.toLowerCase()) || ((_a = el.group) == null ? void 0 : _a.toLowerCase().includes(input.toLowerCase()));
    }
  );
  return filtered.flatMap((component, index, arr) => {
    var _a;
    const hasTitle = (component == null ? void 0 : component.group) && ((_a = arr[index - 1]) == null ? void 0 : _a.group) !== component.group;
    const withTitle = hasTitle && component.group ? [new inquirer3.Separator(chalk9.bold(component.group))] : [];
    return [
      ...withTitle,
      {
        name: ` ${component.label}`,
        value: (component == null ? void 0 : component.value) ? component.value : component
      }
    ];
  });
};
var action8 = async (_options) => {
  var _a, _b, _c;
  inquirer3.registerPrompt("autocomplete", inquirerAutoCompletePrompt);
  const installedPackages = await getInstalledRefinePackagesFromNodeModules();
  const packagesWithConfig = [];
  await Promise.all(
    installedPackages.map(async (pkg) => {
      const hasConfig = await isPackageHaveRefineConfig(pkg.path);
      const isNotDuplicate = packagesWithConfig.findIndex((el) => el.name === pkg.name) === -1;
      if (hasConfig && isNotDuplicate) {
        packagesWithConfig.push(pkg);
      }
    })
  );
  if (packagesWithConfig.length === 0) {
    console.log("No Refine packages found with swizzle configuration.");
    return;
  }
  console.log(
    `${boxen3(
      `Found ${chalk9.blueBright(
        packagesWithConfig.length
      )} installed ${chalk9.blueBright.bold(
        "Refine"
      )} packages with swizzle configuration.`,
      {
        padding: 1,
        textAlignment: "center",
        dimBorder: true,
        borderColor: "blueBright",
        borderStyle: "round"
      }
    )}
`
  );
  const packageConfigs = await Promise.all(
    packagesWithConfig.map(async (pkg) => {
      const config2 = await getRefineConfig(pkg.path, true) ?? await getRefineConfig(pkg.path, false) ?? {
        swizzle: { items: [] }
      };
      return {
        ...pkg,
        config: config2
      };
    })
  );
  const { selectedPackage } = await inquirer3.prompt([
    {
      type: "autocomplete",
      pageSize: 10,
      name: "selectedPackage",
      message: "Which package do you want to swizzle?",
      emptyText: "No packages found.",
      source: getAutocompleteSource(
        packageConfigs.sort(
          (a, b) => {
            var _a2, _b2;
            return (((_a2 = a.config) == null ? void 0 : _a2.group) ?? "").localeCompare(((_b2 = b.config) == null ? void 0 : _b2.group) ?? "");
          }
        ).map((pkg) => {
          var _a2, _b2;
          return {
            label: ((_a2 = pkg.config) == null ? void 0 : _a2.name) ?? pkg.name,
            value: pkg,
            group: (_b2 = pkg.config) == null ? void 0 : _b2.group
          };
        })
      )
    }
  ]);
  const {
    swizzle: { items, transform }
  } = selectedPackage.config;
  let selectedComponent = void 0;
  if (items.length === 0) {
    console.log(
      `No swizzle items found for ${chalk9.bold(
        ((_a = selectedPackage.config) == null ? void 0 : _a.name) ?? selectedPackage.name
      )}`
    );
    return;
  }
  if (items.length === 1) {
    selectedComponent = items[0];
  } else if (items.length > 1) {
    const response = await inquirer3.prompt([
      {
        type: "list",
        pageSize: 10,
        name: "selectedComponent",
        message: "Which component do you want to swizzle?",
        emptyText: "No components found.",
        choices: getAutocompleteSource(
          items.sort((a, b) => a.group.localeCompare(b.group))
        )({}, "")
      }
    ]);
    selectedComponent = response.selectedComponent;
  }
  if (!selectedComponent) {
    console.log(
      `No swizzle items selected for ${chalk9.bold(
        ((_b = selectedPackage.config) == null ? void 0 : _b.name) ?? selectedPackage.name
      )}`
    );
    return;
  }
  const projectPathPrefix = getPathPrefix();
  const createdFiles = await Promise.all(
    selectedComponent.files.map(async (file) => {
      var _a2;
      try {
        const srcPath = file.src ? path4.join(selectedPackage.path, file.src) : void 0;
        const destPath = file.dest ? path4.join(process.cwd(), projectPathPrefix, file.dest) : void 0;
        if (!srcPath) {
          console.log("No src path found for file", file);
          return ["", SWIZZLE_CODES.SOURCE_PATH_NOT_FOUND];
        }
        if (!destPath) {
          console.log("No destination path found for file", file);
          return ["", SWIZZLE_CODES.TARGET_PATH_NOT_FOUND];
        }
        const hasSrc = await pathExists2(srcPath);
        if (!hasSrc) {
          return [destPath, SWIZZLE_CODES.SOURCE_PATH_NOT_A_FILE];
        }
        const srcContent = await readFile(srcPath, "utf-8");
        const isDestExist = await pathExists2(destPath);
        if (isDestExist) {
          return [destPath, SWIZZLE_CODES.TARGET_ALREADY_EXISTS];
        }
        await ensureFile(destPath);
        const parsedContent = parseSwizzleBlocks(srcContent);
        const fileTransformedContent = ((_a2 = file.transform) == null ? void 0 : _a2.call(file, parsedContent)) ?? parsedContent;
        const transformedContent = (transform == null ? void 0 : transform(fileTransformedContent, srcPath, destPath)) ?? fileTransformedContent;
        const reorderedContent = reorderImports(transformedContent);
        const formatted = await prettierFormat(reorderedContent);
        await writeFile(destPath, formatted);
        return [destPath, SWIZZLE_CODES.SUCCESS];
      } catch (error) {
        return ["", SWIZZLE_CODES.UNKNOWN_ERROR];
      }
    })
  );
  if (createdFiles.length > 0) {
    printSwizzleMessage({
      files: createdFiles,
      label: selectedComponent.label,
      message: selectedComponent.message
    });
    if ((_c = selectedComponent == null ? void 0 : selectedComponent.requiredPackages) == null ? void 0 : _c.length) {
      await installRequiredPackages(selectedComponent.requiredPackages);
    }
  }
};
var swizzle_default = swizzle;

// src/commands/update/index.ts
import inquirer5 from "inquirer";
import center2 from "center-align";
import { Option as Option4 } from "commander";
import PackageJson from "@npmcli/package-json";

// src/commands/update/interactive/index.ts
import inquirer4 from "inquirer";
import semverDiff2 from "semver-diff";
import chalk10 from "chalk";

// src/utils/array/index.ts
var findDuplicates = (arr) => {
  const duplicates = arr.filter((item, index) => arr.indexOf(item) !== index);
  const unique = new Set(duplicates);
  return Array.from(unique);
};

// src/commands/update/interactive/index.ts
var promptInteractiveRefineUpdate = async (packages) => {
  const uiGroup = createUIGroup(packages);
  if (!uiGroup) {
    console.log("All `Refine` packages are up to date. \u{1F389}");
    return;
  }
  const inquirerUI = createInquirerUI(uiGroup);
  const answers = await inquirer4.prompt([
    {
      type: "checkbox",
      name: "packages",
      message: "Choose packages to update",
      pageSize: inquirerUI.pageSize,
      choices: inquirerUI.choices,
      validate: validatePrompt
    }
  ]);
  if (answers.packages.length > 0) {
    const packagesObject = {};
    answers.packages.forEach((pckg) => {
      const { name: name3, version } = parsePackageNameAndVersion(pckg);
      packagesObject[name3] = version ?? "latest";
    });
    return packagesObject;
  }
  return null;
};
var validatePrompt = (input) => {
  const inputParsed = input.map((pckg) => {
    return parsePackageNameAndVersion(pckg);
  });
  const names = inputParsed.map((pckg) => pckg.name);
  const duplicates = findDuplicates(names);
  if (duplicates.length > 0) {
    return `You can't update the same package more than once. Please choice one.
 Duplicates: ${duplicates.join(
      ", "
    )}`;
  }
  return true;
};
var createUIGroup = (packages) => {
  if (packages.length === 0) {
    return null;
  }
  const packagesCategorized = {
    patch: [],
    minor: [],
    major: []
  };
  packages.forEach((pckg) => {
    const current = pckg.current;
    const diffWanted = semverDiff2(current, pckg.wanted);
    const diffLatest = semverDiff2(current, pckg.latest);
    if (diffWanted === diffLatest) {
      if (diffLatest) {
        packagesCategorized[diffLatest].push({
          name: pckg.name,
          from: current,
          to: pckg.latest
        });
        return;
      }
    }
    if (diffWanted) {
      packagesCategorized[diffWanted].push({
        name: pckg.name,
        from: current,
        to: pckg.wanted
      });
    }
    if (diffLatest) {
      packagesCategorized[diffLatest].push({
        name: pckg.name,
        from: current,
        to: pckg.latest
      });
    }
  });
  return packagesCategorized;
};
var createInquirerUI = (uiGroup) => {
  let maxNameLength = 0;
  let maxFromLength = 0;
  [uiGroup.patch, uiGroup.minor, uiGroup.major].forEach((group) => {
    group.forEach((pckg) => {
      if (pckg.name.length > maxNameLength) {
        maxNameLength = pckg.name.length;
      }
      if (pckg.from.length > maxFromLength) {
        maxFromLength = pckg.from.length;
      }
    });
  });
  maxNameLength += 2;
  const choices = [];
  const packageColumnText = "Package".padEnd(maxNameLength);
  const currentColumnText = "From".padEnd(maxFromLength);
  const toColumnText = "To";
  const header = `
   ${packageColumnText} ${currentColumnText}${toColumnText.padStart(
    maxFromLength
  )}`;
  choices.push(new inquirer4.Separator(header));
  if (uiGroup.patch.length > 0) {
    choices.push(
      new inquirer4.Separator(chalk10.reset.bold.blue("\nPatch Updates"))
    );
    uiGroup.patch.forEach((pckg) => {
      choices.push({
        name: `${pckg.name.padEnd(maxNameLength)} ${pckg.from.padStart(
          maxFromLength
        )} -> ^${pckg.to}`,
        value: `${pckg.name}@^${pckg.to}`
      });
    });
  }
  if (uiGroup.minor.length > 0) {
    choices.push(
      new inquirer4.Separator(chalk10.reset.bold.blue("\nMinor Updates"))
    );
    uiGroup.minor.forEach((pckg) => {
      choices.push({
        name: `${pckg.name.padEnd(maxNameLength)} ${pckg.from.padStart(
          maxFromLength
        )} -> ^${pckg.to}`,
        value: `${pckg.name}@^${pckg.to}`
      });
    });
  }
  if (uiGroup.major.length > 0) {
    choices.push(
      new inquirer4.Separator(chalk10.reset.bold.blue("\nMajor Updates"))
    );
    uiGroup.major.forEach((pckg) => {
      choices.push({
        name: `${pckg.name.padEnd(maxNameLength)} ${pckg.from.padStart(
          maxFromLength
        )} -> ^${pckg.to}`,
        value: `${pckg.name}@^${pckg.to}`
      });
    });
  }
  const pageSize = choices.length + 6;
  return { choices, pageSize };
};

// src/commands/update/index.ts
import chalk11 from "chalk";
var load4 = (program) => {
  return program.command("update").description(
    "Interactively select and update all `Refine` packages to selected version. To skip the interactive mode, use the `--all` option."
  ).addOption(
    new Option4("-t, --tag [tag]", "Select version to update to.").choices(["next", "latest"]).default(
      "wanted",
      "Version ranges in the `package.json` will be installed"
    )
  ).option(
    "-a, --all",
    "Update all `Refine` packages to the selected `tag`. If `tag` is not provided, version ranges in the `package.json` will be installed. This option skips the interactive mode.",
    false
  ).option(
    "-d, --dry-run",
    "Get outdated packages installation command without automatic updating. If `tag` is not provided, version ranges in the `package.json` will be used.",
    false
  ).action(action9);
};
var action9 = async (options) => {
  const { tag, dryRun, all } = options;
  const packages = await spinner_default(isRefineUptoDate, "Checking for updates...");
  if (!(packages == null ? void 0 : packages.length)) {
    console.log("All `Refine` packages are up to date \u{1F389}");
    return;
  }
  let selectedPackages = null;
  if (all) {
    const selectedPackages2 = await preparePackagesToInstall(tag, packages);
    if (!selectedPackages2)
      return;
    if (dryRun) {
      printInstallCommand(selectedPackages2);
      return;
    }
    runInstallation(selectedPackages2);
    return;
  }
  const { table, width } = getVersionTable(packages) ?? "";
  console.log(center2("Available Updates", width));
  console.log(table);
  console.log(
    `- ${chalk11.yellow(
      chalk11.bold("Current")
    )}: The version of the package that is currently installed`
  );
  console.log(
    `- ${chalk11.yellow(
      chalk11.bold("Wanted")
    )}: The maximum version of the package that satisfies the semver range specified in \`package.json\``
  );
  console.log(
    `- ${chalk11.yellow(
      chalk11.bold("Latest")
    )}: The latest version of the package available on npm`
  );
  console.log();
  const { installationType } = await inquirer5.prompt([
    {
      type: "list",
      name: "installationType",
      message: "Do you want to update all Refine packages for minor and patch versions?",
      choices: [
        {
          name: `Update all packages to latest "minor" version without any breaking changes.`,
          value: "minor"
        },
        {
          name: "Update all packages to the latest version that satisfies the semver(`wanted`) range specified in `package.json`",
          value: "wanted"
        },
        {
          name: `Use interactive mode. Choose this option for "major" version updates.`,
          value: "interactive"
        }
      ]
    }
  ]);
  if (installationType === "interactive" /* INTERACTIVE */) {
    selectedPackages = await promptInteractiveRefineUpdate(packages);
  }
  if (installationType === "wanted" /* WANTED */) {
    selectedPackages = await preparePackagesToInstall("wanted" /* WANTED */, packages);
  }
  if (installationType === "minor" /* MINOR */) {
    selectedPackages = await preparePackagesToInstall(
      "minor" /* MINOR */,
      packages
    );
  }
  if (!selectedPackages)
    return;
  if (dryRun) {
    printInstallCommand(selectedPackages);
  } else {
    runInstallation(selectedPackages);
  }
};
var preparePackagesToInstall = async (tag, packages) => {
  if (tag === "wanted" /* WANTED */) {
    const isAllPackagesAtWantedVersion = packages.every(
      (pkg) => pkg.current === pkg.wanted
    );
    if (isAllPackagesAtWantedVersion) {
      console.log();
      console.log("\u2705 All `Refine` packages are already at the wanted version");
      return null;
    }
  }
  console.log();
  const packagesWithVersion = {};
  for (const pkg of packages) {
    let version = pkg.latest;
    if (tag === "minor" /* MINOR */) {
      const latestMinorVersion = await spinner_default(
        () => getLatestMinorVersionOfPackage(pkg.name, pkg.wanted),
        `Checking for the latest minor version of ${pkg.name}`
      );
      version = `^${latestMinorVersion}`;
    }
    if (tag === "wanted" /* WANTED */) {
      version = getWantedWithPreferredWildcard(pkg.name, pkg.wanted);
    }
    if (tag === "latest" /* LATEST */) {
      version = `^${pkg.latest}`;
    }
    if (tag === "next" /* NEXT */) {
      version = "next" /* NEXT */;
    }
    packagesWithVersion[pkg.name] = version;
  }
  return packagesWithVersion;
};
var printInstallCommand = async (packages) => {
  const pm = await getPreferedPM();
  const commandInstall = pmCommands[pm.name].add;
  let packagesListAsString = "";
  for (const [name3, version] of Object.entries(packages)) {
    packagesListAsString += `${name3}@${version} `;
  }
  console.log();
  console.log(`${pm.name} ${commandInstall.join(" ")} ${packagesListAsString}`);
};
var runInstallation = async (packagesToInstall) => {
  console.log("Updating `Refine` packages...");
  const packageJson = await PackageJson.load(process.cwd());
  packageJson.update({
    dependencies: {
      ...packageJson.content.dependencies ?? {},
      ...packagesToInstall ?? {}
    }
  });
  await packageJson.save();
  installPackages([], "all");
};
var update_default = load4;

// src/commands/whoami/index.ts
import envinfo from "envinfo";
import ora2 from "ora";
var whoami = (program) => {
  return program.command("whoami").description("View the details of the development environment").action(action10);
};
var action10 = async () => {
  const spinner2 = ora2("Loading environment details...").start();
  const info = await envinfo.run(
    {
      System: ["OS", "CPU"],
      Binaries: ["Node", "Yarn", "npm"],
      Browsers: ["Chrome", "Firefox", "Safari"]
    },
    { showNotFound: true, markdown: true }
  );
  const packages = await getInstalledRefinePackages() || [];
  const packagesMarkdown = packages.map((pkg) => {
    return ` - ${pkg.name}: ${pkg.version}`;
  }).join("\n");
  spinner2.stop();
  console.log(info);
  console.log("## Refine Packages:");
  console.log(packagesMarkdown);
};
var whoami_default = whoami;

// src/commands/add/prompt.ts
import chalk14 from "chalk";
import inquirer8 from "inquirer";

// src/commands/add/sub-commands/integration/prompt.ts
import inquirer6 from "inquirer";

// src/commands/add/sub-commands/integration/run-transformer.ts
import execa6 from "execa";
var runTransformer = async (params) => {
  const {
    incompatiblePackages: incompatiblePackages3,
    integrationName,
    requiredPackages: requiredPackages3,
    transformerFileName: transformerFileName3
  } = params;
  if (hasIncomatiblePackages(incompatiblePackages3))
    return;
  await installMissingPackages(requiredPackages3);
  console.log(`\u{1F680} Setting up ${integrationName}...`);
  const jscodeshiftExecutable = __require.resolve(".bin/jscodeshift");
  const { stderr } = execa6.sync(jscodeshiftExecutable, [
    "./",
    "--extensions=ts,tsx,js,jsx",
    "--parser=tsx",
    `--transform=${__dirname}/../src/transformers/integrations/${transformerFileName3}.ts`,
    "--ignore-pattern=.cache",
    "--ignore-pattern=node_modules",
    "--ignore-pattern=build",
    "--ignore-pattern=.next",
    "--ignore-pattern=dist"
  ]);
  if (stderr) {
    console.log(stderr);
  }
  console.log(`\u{1F389} ${integrationName} setup completed!`);
};

// src/commands/add/sub-commands/integration/utils/prettify-choice.ts
import chalk12 from "chalk";
var prettifyChoice = (choice) => {
  const { id: id3, title, description, disabled } = choice;
  if (disabled) {
    return {
      value: id3,
      name: `${chalk12.gray(title)}`,
      disabled: chalk12.redBright(disabled)
    };
  }
  return {
    value: id3,
    name: `${chalk12.blueBright(title)} - ${description}`
  };
};

// src/commands/add/sub-commands/integration/packages/ant-design.ts
var id = "ant-design";
var name = "Ant Design";
var incompatiblePackages = ["@remix-run/react", "next"];
var requiredPackages = ["antd", "@refinedev/antd"];
var transformerFileName = "ant-design";
var AntDesignIntegration = {
  id,
  getChoice: (projectType) => {
    const title = "Ant Design";
    const description = "Setup Ant Design with Refine";
    let disabled;
    if ([
      "nextjs" /* NEXTJS */,
      "remix" /* REMIX */,
      "remix-vite" /* REMIX_VITE */,
      "remix-spa" /* REMIX_SPA */
    ].includes(projectType)) {
      disabled = "Automatic setup only available Vite for now. See the documentation for manual installation: https://refine.dev/docs/ui-integrations/ant-design/introduction/#installation";
    }
    return prettifyChoice({
      id,
      title,
      description,
      disabled
    });
  },
  runTransformer: async () => {
    return await runTransformer({
      incompatiblePackages,
      integrationName: name,
      requiredPackages,
      transformerFileName
    });
  }
};

// src/commands/add/sub-commands/integration/packages/react-router.ts
var id2 = "react-router";
var name2 = "React Router";
var incompatiblePackages2 = ["@remix-run/react", "next"];
var requiredPackages2 = ["react-router", "@refinedev/react-router"];
var transformerFileName2 = "react-router";
var ReactRouterIntegration = {
  id: id2,
  getChoice: (projectType) => {
    const title = "React Router";
    const description = "Setup routing with React Router";
    let disabled;
    if (projectType === "nextjs" /* NEXTJS */) {
      disabled = `Can't be used with Next.js. https://nextjs.org/docs/app/building-your-application/routing`;
    }
    if (projectType === "remix" /* REMIX */ || projectType === "remix-vite" /* REMIX_VITE */ || projectType === "remix-spa" /* REMIX_SPA */) {
      disabled = `Can't be used with Remix. https://remix.run/docs/en/main/discussion/routes`;
    }
    return prettifyChoice({
      id: id2,
      title,
      description,
      disabled
    });
  },
  runTransformer: async () => {
    return await runTransformer({
      incompatiblePackages: incompatiblePackages2,
      integrationName: name2,
      requiredPackages: requiredPackages2,
      transformerFileName: transformerFileName2
    });
  }
};

// src/commands/add/sub-commands/integration/packages/index.ts
var availableIntegrations = [
  AntDesignIntegration,
  ReactRouterIntegration
];

// src/commands/add/sub-commands/integration/prompt.ts
var buildIntegrationChoices = () => {
  const projectType = getProjectType();
  const integrationChoices = availableIntegrations.map(
    (integration) => integration.getChoice(projectType)
  );
  if (integrationChoices.every((choice) => choice.disabled)) {
    return [
      {
        value: "none",
        name: "No integration available for this project type."
      },
      ...integrationChoices
    ];
  }
  return integrationChoices;
};
var addIntegrationPrompt = async () => {
  return await inquirer6.prompt([
    {
      type: "list",
      name: "id",
      message: "Which integration do you want to add?",
      choices: buildIntegrationChoices(),
      default: "none"
    }
  ]);
};

// src/commands/add/sub-commands/provider/prompt.ts
import chalk13 from "chalk";
import inquirer7 from "inquirer";

// src/commands/add/sub-commands/provider/create-providers.ts
import {
  copySync as copySync2,
  existsSync as existsSync2,
  mkdirSync as mkdirSync2,
  pathExistsSync as pathExistsSync2,
  readdirSync as readdirSync2
} from "fs-extra";
import { join as join3, relative } from "path";

// src/commands/add/sub-commands/provider/providers.ts
var availableProviders = [
  {
    id: "auth",
    title: "Auth provider",
    description: "Manage user authentication and authorization",
    fileName: "auth-provider.tsx",
    templateFileName: "demo-auth-provider.tsx.template"
  },
  {
    id: "live",
    title: "Live provider",
    description: "Enable real-time updates and synchronization",
    fileName: "live-provider.tsx",
    templateFileName: "demo-live-provider.tsx.template"
  },
  {
    id: "data",
    title: "Data provider",
    description: "Communicate with your API",
    fileName: "data-provider.tsx",
    templateFileName: "demo-data-provider.tsx.template"
  },
  {
    id: "access-control",
    title: "Access Control",
    description: "Manage user permissions & roles",
    fileName: "access-control-provider.tsx",
    templateFileName: "demo-access-control-provider.tsx.template"
  },
  {
    id: "notification",
    title: "Notification provider",
    description: "Display in-app alerts and messages",
    fileName: "notification-provider.tsx",
    templateFileName: "demo-notification-provider.tsx.template"
  },
  {
    id: "i18n",
    title: "I18n provider",
    description: "Support multiple languages and locales",
    fileName: "i18n-provider.tsx",
    templateFileName: "demo-i18n-provider.tsx.template"
  },
  {
    id: "audit-log",
    title: "Audit Log provider",
    description: "Display audit logs for your resources",
    fileName: "audit-log-provider.tsx",
    templateFileName: "demo-audit-log-provider.tsx.template"
  }
];

// src/commands/add/sub-commands/provider/create-providers.ts
var baseTemplatePath = `${__dirname}/../templates/provider`;
var baseAssetsPath = `${__dirname}/../templates/assets`;
var createProviders = (providerIds, pathFromArgs) => {
  providerIds.forEach((providerId) => {
    const { fileName, templateFileName } = getProviderOptions(providerId);
    const projectFilesBasePath = getFilesPathByProject(getProjectType());
    const folderPath = pathFromArgs ?? getDefaultPath();
    const filePath = join3(folderPath, fileName);
    const fullPath = join3(process.cwd(), folderPath, fileName);
    const projectFilesPath = join3(process.cwd(), projectFilesBasePath);
    if (pathExistsSync2(fullPath)) {
      console.error(`\u274C Provider (${filePath}) already exist!`);
      return;
    }
    mkdirSync2(folderPath, { recursive: true });
    copySync2(`${baseTemplatePath}/${templateFileName}`, fullPath);
    console.log(`\u{1F389} Provider (${filePath}) created successfully!`);
    const copiedAssets = [];
    const failedAssets = [];
    if (pathExistsSync2(`${baseAssetsPath}/${providerId}`)) {
      try {
        readdirSync2(`${baseAssetsPath}/${providerId}`, {
          recursive: true,
          withFileTypes: true
        }).forEach((file) => {
          if (!file.isDirectory()) {
            const fromPath = join3(file.path, file.name);
            const destinationPath = join3(
              projectFilesPath,
              relative(join3(baseAssetsPath, providerId), file.path),
              file.name
            );
            const relativeDestinationPath = join3(
              projectFilesBasePath,
              relative(projectFilesPath, destinationPath)
            );
            if (existsSync2(destinationPath)) {
              failedAssets.push(relativeDestinationPath);
            } else {
              try {
                copySync2(fromPath, destinationPath);
                copiedAssets.push(relativeDestinationPath);
              } catch (error) {
                failedAssets.push(relativeDestinationPath);
              }
            }
          }
        });
      } catch (error) {
      }
    }
    if (copiedAssets.length) {
      console.log(`\u{1F389} Created additional assets: ${copiedAssets.join(", ")}`);
    }
    if (failedAssets.length) {
      console.error(`\u274C Failed to create assets: ${failedAssets.join(", ")}`);
    }
  });
};
var getProviderOptions = (providerId) => {
  const provider = availableProviders.find((p) => p.id === providerId);
  if (!provider) {
    throw new Error(`Invalid provider: ${providerId}`);
  }
  return provider;
};
var getDefaultPath = () => {
  const projectType = getProjectType();
  const { path: path5 } = getProviderPath(projectType);
  return path5;
};

// src/commands/add/sub-commands/provider/prompt.ts
var buildProviderChoices = () => {
  return availableProviders.map((provider) => {
    const { id: id3, title, description } = provider;
    return {
      value: id3,
      name: `${chalk13.blueBright(title)} - ${description}`
    };
  });
};
var addProviderPrompt = async () => {
  return await inquirer7.prompt([
    {
      type: "checkbox",
      name: "providers",
      message: "Which providers do you want to add?",
      choices: buildProviderChoices()
    },
    {
      type: "input",
      name: "providersPath",
      message: "Where do you want to generate the providers?",
      default: getDefaultPath()
    }
  ]);
};

// src/commands/add/prompt.ts
var wrapChoices = (group, choices) => {
  return choices.map((choice) => {
    return {
      ...choice,
      name: ` . ${choice.name}`,
      value: {
        group,
        component: choice.value
      }
    };
  });
};
var addCommandPrompt = async () => {
  return await inquirer8.prompt([
    {
      type: "list",
      name: "component",
      message: "What do you want to add?",
      choices: [
        new inquirer8.Separator(chalk14.bold("Provider")),
        ...wrapChoices("provider", buildProviderChoices()),
        new inquirer8.Separator(chalk14.bold("Integration")),
        ...wrapChoices("integration", buildIntegrationChoices()),
        new inquirer8.Separator(chalk14.bold("Resource")),
        {
          name: chalk14.blueBright(" .  Add new resource"),
          value: {
            group: "resource",
            component: "resource"
          }
        }
      ],
      pageSize: 25
    }
  ]);
};

// src/commands/add/sub-commands/integration/command.ts
import { Argument as Argument2, Command as Command2 } from "commander";
var addIntegrationAction = async (name3) => {
  let integrationID = name3;
  if (!integrationID) {
    const answer = await addIntegrationPrompt();
    integrationID = answer.id;
  }
  const integration = availableIntegrations.find(
    (integration2) => integration2.id === integrationID
  );
  if (integration) {
    await integration.runTransformer();
  }
};
var IntegrationCommand = new Command2("integration").addArgument(
  new Argument2("[name]", "Name of the integration").choices(
    availableIntegrations.map((integration) => integration.id)
  )
).action(addIntegrationAction);

// src/commands/add/sub-commands/provider/command.ts
import { Argument as Argument3, Command as Command3 } from "commander";
var createProviderAction = async (providers, options) => {
  if (!providers.length) {
    const { providers: providers2, providersPath } = await addProviderPrompt();
    return createProviders(providers2, providersPath);
  }
  createProviders(providers, options.path);
};
var ProviderCommand = new Command3("provider").addArgument(
  new Argument3("[providers...]", "Create provider(s)").choices(availableProviders.map((provider) => provider.id)).default([])
).option("-p, --path [path]", "Path to generate providers").action(createProviderAction);

// src/commands/add/sub-commands/resource/command.ts
import { Argument as Argument4, Command as Command4 } from "commander";
var createResourceAction = async (resources, options, command) => {
  createResources(
    {
      actions: options == null ? void 0 : options.actions,
      path: command.optsWithGlobals().path
    },
    resources
  );
};
var ResourceCommand = new Command4("resource").addArgument(new Argument4("[resources...]", "Create new resource(s)")).option("-p, --path [path]", "Path to generated resource files").option(
  "-a, --actions [actions]",
  "Only generate the specified resource actions. (ex: list,create,edit,show)",
  "list,create,edit,show"
).action(createResourceAction);

// src/commands/add/index.ts
var load5 = (program) => {
  return program.command("add").description("Add new resources, providers, or integrations").allowExcessArguments(false).action(addCommandAction).addCommand(ResourceCommand).addCommand(ProviderCommand).addCommand(IntegrationCommand);
};
var addCommandAction = async () => {
  const { component } = await addCommandPrompt();
  if (component.group === "provider") {
    createProviders([component.component]);
  }
  if (component.group === "integration") {
    const integration = availableIntegrations.find(
      (integration2) => integration2.id === component.component
    );
    await (integration == null ? void 0 : integration.runTransformer());
  }
  if (component.group === "resource") {
    await createResources({}, []);
  }
};
var add_default = load5;

// src/utils/os/index.ts
import envinfo2 from "envinfo";
import os from "os";
var getOSType = () => {
  const osPlatform = os.type();
  const types = {
    Darwin: "macOS",
    Linux: "Linux",
    Windows_NT: "Windows"
  };
  return types[osPlatform];
};
var getOS = async () => {
  const [_, OSInfo] = await envinfo2.helpers.getOSInfo();
  return {
    name: getOSType(),
    version: OSInfo
  };
};

// src/telemetry/index.ts
import fetch2 from "node-fetch";
var getTelemetryData = async () => {
  const os2 = await getOS();
  const data = {
    nodeEnv: ENV.NODE_ENV,
    nodeVersion: process.version,
    os: os2.name,
    osVersion: os2.version,
    command: process.argv[2],
    packages: await getInstalledRefinePackages() || [],
    projectFramework: getProjectType(),
    projectId: getRefineProjectId()
  };
  return data;
};
var telemetryHook = async () => {
  if (ENV.REFINE_NO_TELEMETRY === "true")
    return;
  try {
    const data = await getTelemetryData();
    await fetch2("https://telemetry.refine.dev/cli", {
      method: "POST",
      body: JSON.stringify(data),
      headers: { "Content-Type": "application/json" }
    });
  } catch (error) {
  }
};

// src/utils/announcement/index.tsx
import matter from "gray-matter";
import boxen4 from "boxen";
var ANNOUNCEMENT_URL = "https://raw.githubusercontent.com/refinedev/refine/main/packages/cli/ANNOUNCEMENTS.md";
var ANNOUNCEMENT_DELIMITER = "---announcement";
var splitAnnouncements = (feed) => {
  const sections = feed.split(ANNOUNCEMENT_DELIMITER);
  return sections.slice(1).map((section) => `${ANNOUNCEMENT_DELIMITER}${section}`);
};
var parseAnnouncement = (raw) => {
  const fixed = raw.replace(ANNOUNCEMENT_DELIMITER, "---");
  const parsed = matter(fixed);
  const content = (parsed.content.length === 0 ? fixed.replace(/---/g, "") : parsed.content.replace(/---/g, "")).trim();
  return {
    ...parsed.data,
    content
  };
};
var getAnnouncements = async () => {
  try {
    const response = await fetch(ANNOUNCEMENT_URL).then((res) => res.text()).catch(() => "");
    const announcements = splitAnnouncements(response).map(
      (section) => parseAnnouncement(section)
    );
    return announcements;
  } catch (_) {
    return [];
  }
};
var printAnnouncements = async () => {
  const announcements = await getAnnouncements();
  const visibleAnnouncements = announcements.filter(
    (a) => Boolean(a.hidden) === false
  );
  if (visibleAnnouncements.length === 0) {
    return;
  }
  const stringAnnouncements = visibleAnnouncements.map((a) => {
    const dash = visibleAnnouncements.length > 1 ? "\u2014 " : "";
    const content = markedTerminalRenderer(a.content);
    return `${dash}${content}`;
  }).join("").trim();
  console.log(
    boxen4(stringAnnouncements, {
      padding: 1,
      margin: 0,
      borderStyle: "round",
      borderColor: "blueBright",
      titleAlignment: "left"
    })
  );
};

// src/cli.ts
var REFINE_CLI_VERSION = "1.0.0";
var bootstrap = () => {
  const program = new Command5();
  program.version(
    `@refinedev/cli@${REFINE_CLI_VERSION}`,
    "-v, --version",
    "Output the current version."
  ).description(
    figlet.textSync("refine", {
      font: "Isometric1",
      horizontalLayout: "full",
      verticalLayout: "full",
      whitespaceBreak: true
    })
  ).usage("<command> [options]").helpOption("-h, --help", "Output usage information.");
  swizzle_default(program);
  create_resource_default(program);
  update_default(program);
  dev_default(program);
  build_default(program);
  start_default(program);
  run_default(program);
  check_updates_default(program);
  whoami_default(program);
  devtools_default(program);
  add_default(program);
  program.hook("preAction", async (thisCommand) => {
    if (thisCommand.args.includes("dev")) {
      await printAnnouncements();
    }
  });
  program.hook("postAction", (thisCommand) => {
    const command = thisCommand.args[0];
    if (["run"].includes(command))
      return;
    telemetryHook();
  });
  program.parse(process.argv);
  if (!process.argv.slice(2).length) {
    program.outputHelp();
  }
};
bootstrap();
//# sourceMappingURL=cli.mjs.map