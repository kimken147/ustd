"use client"

// src/event-types.ts
var DevtoolsEvent = /* @__PURE__ */ ((DevtoolsEvent2) => {
  DevtoolsEvent2["RELOAD"] = "devtools:reload";
  DevtoolsEvent2["DEVTOOLS_INIT"] = "devtools:init";
  DevtoolsEvent2["DEVTOOLS_ALREADY_CONNECTED"] = "devtools:already-connected";
  DevtoolsEvent2["ACTIVITY"] = "devtools:send-activity";
  DevtoolsEvent2["DEVTOOLS_ACTIVITY_UPDATE"] = "devtools:activity-update";
  DevtoolsEvent2["DEVTOOLS_CONNECTED_APP"] = "devtools:connected-app";
  DevtoolsEvent2["DEVTOOLS_DISCONNECTED_APP"] = "devtools:disconnected-app";
  DevtoolsEvent2["DEVTOOLS_HIGHLIGHT_IN_MONITOR"] = "devtools:highlight-in-monitor";
  DevtoolsEvent2["DEVTOOLS_HIGHLIGHT_IN_MONITOR_ACTION"] = "devtools:highlight-in-monitor-action";
  DevtoolsEvent2["DEVTOOLS_LOGIN_SUCCESS"] = "devtools:login-success";
  DevtoolsEvent2["DEVTOOLS_DISPLAY_LOGIN_FAILURE"] = "devtools:display-login-failure";
  DevtoolsEvent2["DEVTOOLS_LOGIN_FAILURE"] = "devtools:login-failure";
  DevtoolsEvent2["DEVTOOLS_RELOAD_AFTER_LOGIN"] = "devtools:reload-after-login";
  DevtoolsEvent2["DEVTOOLS_INVALIDATE_QUERY"] = "devtools:invalidate-query";
  DevtoolsEvent2["DEVTOOLS_INVALIDATE_QUERY_ACTION"] = "devtools:invalidate-query-action";
  return DevtoolsEvent2;
})(DevtoolsEvent || {});

// src/scopes.ts
var scopes = {
  useCan: "access-control",
  useLog: "audit-log",
  useLogList: "audit-log",
  useCreate: "data",
  useCreateMany: "data",
  useCustom: "data",
  useCustomMutation: "data",
  useDelete: "data",
  useDeleteMany: "data",
  useInfiniteList: "data",
  useList: "data",
  useMany: "data",
  useOne: "data",
  useUpdate: "data",
  useUpdateMany: "data",
  useForgotPassword: "auth",
  useGetIdentity: "auth",
  useIsAuthenticated: "auth",
  useLogin: "auth",
  useLogout: "auth",
  useOnError: "auth",
  usePermissions: "auth",
  useRegister: "auth",
  useUpdatePassword: "auth"
};
var hooksByScope = Object.entries(scopes).reduce(
  (acc, [hook, scope]) => {
    if (!acc[scope]) {
      acc[scope] = [];
    }
    acc[scope].push(hook);
    return acc;
  },
  {}
);

// src/context.tsx
import React from "react";

// src/send.ts
async function send(ws, event, payload) {
  if (ws.readyState !== ws.OPEN) {
    await new Promise((resolve) => {
      const listener = () => {
        ws.send(JSON.stringify({ event, payload }));
        resolve();
        ws.removeEventListener("open", listener);
      };
      ws.addEventListener("open", listener);
    });
    return;
  }
  ws.send(JSON.stringify({ event, payload }));
  return;
}

// src/context.tsx
var DevToolsContext = React.createContext({
  __devtools: false,
  httpUrl: "http://localhost:5001",
  wsUrl: "ws://localhost:5001",
  ws: null
});
var DevToolsContextProvider = ({
  __devtools,
  url = ["http://localhost:5001", "ws://localhost:5001"],
  children
}) => {
  const httpUrl = Array.isArray(url) ? url[0] : url;
  const wsUrl = Array.isArray(url) ? url[1] : url.replace(/http(s)?:\/\//, "ws$1://");
  const [values, setValues] = React.useState({
    __devtools: __devtools ?? false,
    httpUrl,
    wsUrl,
    ws: null
  });
  const [ws, setWs] = React.useState(null);
  React.useEffect(() => {
    let timeout = null;
    const wsInstance = new WebSocket(values.wsUrl);
    wsInstance.addEventListener("open", () => {
      if (!values.__devtools) {
        timeout = setTimeout(() => {
          send(wsInstance, "devtools:init" /* DEVTOOLS_INIT */, {
            url: window.location.origin
          });
        }, 300);
      }
    });
    setWs(wsInstance);
    return () => {
      if (timeout)
        clearTimeout(timeout);
      if (wsInstance.readyState === WebSocket.CONNECTING) {
        wsInstance.addEventListener("open", () => {
          wsInstance.close(1e3, window.location.origin);
        });
      } else {
        wsInstance.close(1e3, window.location.origin);
      }
    };
  }, []);
  const contextValues = React.useMemo(
    () => ({
      ...values,
      ws
    }),
    [values, ws]
  );
  return /* @__PURE__ */ React.createElement(DevToolsContext.Provider, { value: contextValues }, children);
};

// src/receive.ts
function receive(ws, event, callback) {
  const listener = (e) => {
    const { event: receivedEvent, payload } = JSON.parse(e.data);
    if (event === receivedEvent) {
      callback(payload);
    }
  };
  ws.addEventListener("message", listener);
  return () => {
    ws.removeEventListener("message", listener);
  };
}
export {
  DevToolsContext,
  DevToolsContextProvider,
  DevtoolsEvent,
  hooksByScope,
  receive,
  scopes,
  send
};
//# sourceMappingURL=index.mjs.map