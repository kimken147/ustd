var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});

// src/index.ts
import express2 from "express";
import { DevtoolsEvent as DevtoolsEvent2, receive, send as send2 } from "@refinedev/devtools-shared";

// src/serve-client.ts
import express from "express";
import path from "path";
var serveClient = (app) => {
  app.use(express.static(path.join(__dirname, "client")));
  app.use((req, res, next) => {
    if (req.path.startsWith("/api")) {
      return next();
    }
    if (req.path.startsWith("/open-in-editor")) {
      return next();
    }
    res.status(200).sendFile(path.join(`${__dirname}/client/index.html`));
  });
};

// src/serve-ws.ts
import WebSocket from "ws";

// src/constants.ts
import dotenv from "dotenv";
var refineEnv = {};
dotenv.config({ processEnv: refineEnv });
var RAW_ENV_REFINE_DEVTOOLS_PORT = process.env.REFINE_DEVTOOLS_PORT || refineEnv.REFINE_DEVTOOLS_PORT;
var DEFAULT_SERVER_PORT = 5001;
var SERVER_PORT = Number(RAW_ENV_REFINE_DEVTOOLS_PORT) || DEFAULT_SERVER_PORT;
var AUTH_SERVER_URL = false ? "https://develop.auth.refine.dev" : "https://auth.refine.dev";
var REFINE_API_URL = false ? "https://develop.cloud.refine.dev" : "https://cloud2.refine.dev";
var AUTH_TRIGGER_API_PATH = "/api/login";
var AUTH_CALLBACK_API_PATH = "/api/login-callback";
var AUTH_CALLBACK_UI_PATH = "/after-login";
var FEED_MD_URL = "https://raw.githubusercontent.com/refinedev/refine/main/packages/devtools-server/FEED.md";

// src/serve-ws.ts
import { bold, cyanBright } from "chalk";
var serveWs = (server2, onError) => {
  const ws = new WebSocket.Server({ server: server2 }).on("error", (error) => {
    if ((error == null ? void 0 : error.code) === "EADDRINUSE") {
      console.error(
        `
${cyanBright.bold("\u2717 ")}${bold(
          "Refine Devtools server"
        )} (websocket) failed to start. Port ${SERVER_PORT} is already in use.
`
      );
    } else {
      console.error(
        `
${cyanBright.bold("\u2717 ")}${bold("error from refine devtools")}`,
        error
      );
    }
    ws.close(() => {
      if (false) {
        console.log("Process terminated");
      }
    });
    onError();
  });
  ws.on("connection", (client) => {
    client.on("close", () => {
      client.terminate();
    });
  });
  process.on("SIGTERM", () => {
    ws.close(() => {
      if (false) {
        console.log("Process terminated");
      }
    });
  });
  return ws;
};

// src/reload-on-change.ts
import "lodash-es/debounce.js";
import "@refinedev/devtools-shared";
import "ws";
var reloadOnChange = false ? (ws) => {
  const reloadEmitter = debounce(() => {
    setTimeout(() => {
      ws.clients.forEach((client) => {
        if (client.readyState === OPEN) {
          console.log("Reloading connected client...");
          send(client, DevtoolsEvent.RELOAD, {});
        }
      });
    }, 800);
  }, 1e3);
  const watcher = fs.watch(
    path.resolve(__dirname, "client"),
    { recursive: true },
    reloadEmitter
  );
  process.on("SIGTERM", () => {
    watcher.close();
  });
} : () => 0;

// src/setup-server.ts
import { bold as bold2, cyanBright as cyanBright2 } from "chalk";
import http from "http";
var setupServer = (app, onError) => {
  const server2 = http.createServer(app);
  server2.on("error", (error) => {
    if ((error == null ? void 0 : error.code) === "EADDRINUSE") {
      console.error(
        `
${cyanBright2.bold("\u2717 ")}${bold2(
          "Refine Devtools server"
        )} (http) failed to start. Port ${SERVER_PORT} is already in use.
`
      );
      console.info(
        `${cyanBright2.bold(
          "\u2139 "
        )}You can change the port by setting the ${bold2(
          "REFINE_DEVTOOLS_PORT"
        )} environment variable.`
      );
    } else {
      console.error(
        `
${cyanBright2.bold("\u2717 ")}${bold2(
          "error from Refine Devtools"
        )}`,
        error
      );
    }
    server2.close(() => {
      if (false) {
        console.log("Process terminated");
      }
    });
    onError();
  }).on("listening", () => {
    console.log(
      `
${cyanBright2.bold("\u2713 ")}${bold2(
        "Refine Devtools"
      )} is running at port ${cyanBright2.bold(SERVER_PORT)}
`
    );
  });
  process.on("SIGTERM", () => {
    server2.close(() => {
      if (false) {
        console.log("Process terminated");
      }
    });
  });
  server2.listen(SERVER_PORT, void 0, void 0, () => {
    if (false) {
      console.log(`Server started on PORT ${SERVER_PORT}`);
    }
  });
  return server2;
};

// src/create-db.ts
var defaultData = {
  connectedApp: null,
  clientWs: null,
  // connections
  devtoolsWsClients: [],
  appWsClients: [],
  // data
  activities: [],
  packages: []
};
var createDb = () => {
  return {
    ...defaultData
  };
};

// src/serve-api.ts
import { json } from "express";
import uniq from "lodash-es/uniq.js";

// src/feed/get-feed.ts
import fetch from "node-fetch";
import matter from "gray-matter";
import { marked } from "marked";
import sanitizeHtml from "sanitize-html";
var splitSections = (feed) => {
  const sections = feed.split("---section");
  return sections.slice(1).map((section) => `---section${section}`);
};
var contentToHtml = (content) => {
  const renderer = new marked.Renderer();
  renderer.link = function(...args) {
    const out = marked.Renderer.prototype.link.apply(this, args);
    return out.replace(/^<a/, '<a target="_blank" rel="noopener noreferrer"');
  };
  const html = marked(content, {
    renderer
  });
  return sanitizeHtml(html, {
    allowedTags: sanitizeHtml.defaults.allowedTags.concat(["img"]),
    allowedAttributes: {
      ...sanitizeHtml.defaults.allowedAttributes,
      img: ["src"]
    }
  });
};
var parseSection = (section) => {
  const parsed = matter(section.replace("---section", "---"));
  return {
    ...parsed.data,
    content: contentToHtml(parsed.content)
  };
};
var fetchFeed = async () => {
  try {
    const response = await fetch(FEED_MD_URL);
    return response.text();
  } catch (_) {
    return "";
  }
};
var getFeed = async () => {
  try {
    const rawContent = await fetchFeed();
    const rawSections = splitSections(rawContent);
    const sections = rawSections.map(parseSection);
    return sections;
  } catch (e) {
    return [];
  }
};

// src/packages/get-installed-package-data.ts
import fs from "fs";

// src/packages/get-installed-package-json-path.ts
import path2 from "path";
import globby from "globby";
var getInstalledPackageJSONPath = async (packageName) => {
  try {
    const filesFromGlobbySearch = await globby(
      `node_modules/${packageName}/package.json`,
      {
        onlyFiles: true
      }
    );
    let fileFromModule = null;
    try {
      const pkgJsonPath = __require.resolve(
        path2.join(packageName, "package.json")
      );
      if (pkgJsonPath) {
        fileFromModule = pkgJsonPath;
      }
    } catch (err) {
    }
    return [
      ...filesFromGlobbySearch,
      ...fileFromModule ? [fileFromModule] : []
    ][0] ?? null;
  } catch (err) {
    return null;
  }
};

// src/packages/get-installed-package-data.ts
var getInstalledPackageData = async (packageName) => {
  try {
    const packagePath = await getInstalledPackageJSONPath(packageName);
    if (!packagePath) {
      return null;
    }
    const parsed = JSON.parse(
      fs.readFileSync(packagePath, { encoding: "utf-8" })
    );
    return {
      name: parsed.name,
      version: parsed.version,
      description: parsed.description
    };
  } catch (e) {
    return null;
  }
};

// src/packages/get-packages-from-package-json.ts
import path3 from "path";
import { readJSON } from "fs-extra";
var getPackagesFromPackageJSON = async (projectPath = process.cwd()) => {
  const packageJson = await readJSON(path3.join(projectPath, "package.json"), {
    encoding: "utf-8"
  });
  const refinePackages = Object.keys(packageJson.dependencies).filter(
    (packageName) => packageName.startsWith("@refinedev/")
  );
  return refinePackages;
};

// src/packages/get-changelog.ts
var getChangelog = (packageName) => {
  return packageName.replace("@refinedev/", "https://c.refine.dev/");
};

// src/packages/get-documentation.ts
var getDocumentation = (packageName) => {
  return "https://refine.dev/docs/api-reference/general-concepts/";
};

// src/packages/get-all-packages.ts
var getAllPackages = async (projectPath) => {
  try {
    const refinePackages = await getPackagesFromPackageJSON(projectPath);
    const installedVersions = await Promise.all(
      refinePackages.map(async (packageName) => {
        const currentInfo = await getInstalledPackageData(packageName);
        return {
          name: packageName,
          currentVersion: currentInfo == null ? void 0 : currentInfo.version,
          description: currentInfo == null ? void 0 : currentInfo.description,
          changelog: getChangelog(packageName),
          documentation: getDocumentation(packageName)
        };
      })
    );
    return installedVersions;
  } catch (error) {
    return [];
  }
};

// src/packages/get-available-packages.ts
import dedent from "dedent";
var AVAILABLE_PACKAGES = [
  {
    name: "@refinedev/ably",
    description: "Ably integration for Refine",
    install: "npm install @refinedev/ably",
    usage: dedent(
      `
            import { liveProvider, Ably } from "@refinedev/ably";

            export const ablyClient = new Ably.Realtime("YOUR_API_TOKEN");

            const App = () => {
                return (
                    <Refine
                        liveProvider={liveProvider(ablyClient)}
                        /* ... */
                    >
                        {/* ... */}
                    </Refine>
                );
            };
        `.trim()
    )
  },
  {
    name: "@refinedev/airtable",
    description: "Airtable integration for Refine",
    install: "npm install @refinedev/airtable",
    usage: dedent(
      `
            import dataProvider from "@refinedev/airtable";

            const App = () => {
                return (
                    <Refine
                        dataProvider={dataProvider("API_KEY", "BASE_ID")}
                        /* ... */
                    >
                        {/* ... */}
                    </Refine>
                );
            };
            `.trim()
    )
  },
  {
    name: "@refinedev/antd",
    description: "Ant Design integration for Refine",
    install: "npm install @refinedev/antd antd",
    usage: dedent(
      `
            import { ThemedLayout } from "@refinedev/antd";

            import "@refinedev/antd/dist/reset.css";

            const App = () => {
                return (
                    <Refine
                        /* ... */
                    >
                        <ThemedLayout>
                            {/* ... */}
                        </ThemedLayout>
                    </Refine>
                );
            };
            `.trim()
    )
  },
  {
    name: "@refinedev/appwrite",
    description: "Appwrite integration for Refine",
    install: "npm install @refinedev/appwrite",
    usage: dedent(
      `
            import { dataProvider, liveProvider, Account, Appwrite, Storage } from "@refinedev/appwrite";

            const appwriteClient = new Appwrite();
            appwriteClient.setEndpoint("API_URL").setProject("PROJECT_ID");

            const App = () => {
                return (
                    <Refine
                        dataProvider={dataProvider(appwriteClient, { databaseId: "default" })}
                        liveProvider={liveProvider(appwriteClient, { databaseId: "default" })}
                        /* ... */
                    >
                        <ThemedLayout>
                            {/* ... */}
                        </ThemedLayout>
                    </Refine>
                );
            };
            `.trim()
    )
  },
  {
    name: "@refinedev/chakra-ui",
    description: "Chakra UI integration for Refine",
    install: "npm install @refinedev/chakra-ui @chakra-ui/react @emotion/react @emotion/styled framer-motion @tabler/icons-react",
    usage: dedent(
      `
            import { ThemedLayout } from "@refinedev/chakra-ui";
            import { ChakraProvider } from "@chakra-ui/react";

            const App = () => {
                return (
                        <ChakraProvider>
                        <Refine
                            /* ... */
                        >
                            <ThemedLayout>
                                {/* ... */}
                            </ThemedLayout>
                        </Refine>
                    </ChakraProvider>
                );
            };
            `.trim()
    )
  },
  {
    name: "@refinedev/graphql",
    description: "GraphQL integration for Refine",
    install: "npm install @refinedev/graphql",
    usage: dedent(
      `
            import dataProvider, { GraphQLClient } from "@refinedev/graphql";

            const client = new GraphQLClient("YOUR_API_URL");

            const App = () => {
                return (
                    <Refine
                        dataProvider={dataProvider(client)}
                        /* ... */
                    >
                        {/* ... */}
                    </Refine>
                );
            };
            `.trim()
    )
  },
  {
    name: "@refinedev/hasura",
    description: "GraphQL integration for Refine",
    install: "npm install @refinedev/hasura",
    usage: dedent(
      `
            import dataProvider, { GraphQLClient } from "@refinedev/hasura";

            const client = new GraphQLClient("HASURA_API_URL", {
                headers: {
                    "x-hasura-role": "public",
                },
            });

            const App = () => {
                return (
                    <Refine
                        dataProvider={dataProvider(client)}
                        /* ... */
                    >
                        {/* ... */}
                    </Refine>
                );
            };
            `.trim()
    )
  },
  {
    name: "@refinedev/inferencer",
    description: "Auto generate views based on your APIs with Refine",
    install: "npm install @refinedev/inferencer",
    usage: dedent(
      `
        import { AntdInferencer } from "@refinedev/inferencer/antd";

        const App = () => {
            return (
                <Refine
                    /* ... */
                >
                    <AntdInferencer action="list" resource="posts" />
                </Refine>
            );
        };
        `.trim()
    )
  },
  {
    name: "@refinedev/kbar",
    description: "Command palette integration with kbar for Refine",
    install: "npm install @refinedev/kbar",
    usage: dedent(
      `
            import { RefineKbar, RefineKbarProvider } from "@refinedev/kbar";

            const App = () => {
                return (
                    <RefineKbarProvider>
                        <Refine
                            /* ... */
                        >
                            <RefineKbar />
                        </Refine>
                    </RefineKbarProvider>
                );
            };
        `.trim()
    )
  },
  {
    name: "@refinedev/mantine",
    description: "Mantine UI integration for Refine",
    install: "npm install @refinedev/mantine @refinedev/react-table @mantine/core @mantine/hooks @mantine/form @mantine/notifications @emotion/react @tabler/icons-react",
    usage: dedent(
      `
            import { ThemedLayout } from "@refinedev/mantine";
            import { MantineProvider } from "@mantine/core";

            const App = () => {
                return (
                    <MantineProvider>
                        <Refine
                            /* ... */
                        >
                            <ThemedLayout>
                                {/* ... */}
                            </ThemedLayout>
                        </Refine>
                    </MantineProvider>
                );
            };
            `.trim()
    )
  },
  {
    name: "@refinedev/medusa",
    description: "Medusa store integration for Refine",
    install: "npm install @refinedev/medusa",
    usage: dedent(
      `
            import dataProvider, { authProvider } from "@refinedev/medusa";

            const App = () => {
                return (
                    <Refine
                        dataProvider={dataProvider("API_URL")}
                        authProvider={authProvider("API_URL")}
                        /* ... */
                    >
                        {/* ... */}
                    </Refine>
                );
            };
            `.trim()
    )
  },
  {
    name: "@refinedev/mui",
    description: "Material UI integration for Refine",
    install: "npm install @refinedev/mui @refinedev/react-hook-form @mui/material @mui/lab @mui/x-data-grid @emotion/react @emotion/styled react-hook-form",
    usage: dedent(
      `
            import { ThemedLayout } from "@refinedev/mui";

            import CssBaseline from "@mui/material/CssBaseline";
            import GlobalStyles from "@mui/material/GlobalStyles";
            import { ThemeProvider } from "@mui/material/styles";

            const App = () => {
                return (
                    <ThemeProvider>
                        <CssBaseline />
                        <GlobalStyles styles={{ html: { WebkitFontSmoothing: "auto" } }} />
                        <Refine
                            /* ... */
                        >
                            <ThemedLayout>
                                {/* ... */}
                            </ThemedLayout>
                        </Refine>
                    </ThemeProvider>
                );
            };
            `.trim()
    )
  },
  {
    name: "@refinedev/nestjs-query",
    description: "NestJS Query data provider integration for Refine",
    install: "npm install @refinedev/nestjs-query graphql-ws",
    usage: dedent(
      `
            import dataProvider, {
                GraphQLClient,
                liveProvider,
            } from "@refinedev/nestjs-query";

            import { createClient } from "graphql-ws";

            const App = () => {
                return (
                    <Refine
                        dataProvider={dataProvider(new GraphQLClient( "API_URL" ))}
                        liveProvider={liveProvider(createClient({ url: "WS_URL" }))}
                        /* ... */
                    >
                        {/* ... */}
                    </Refine>
                );
            };
            `.trim()
    )
  },
  {
    name: "@refinedev/nestjsx-crud",
    description: "NestJSX CRUD data provider integration for Refine",
    install: "npm install @refinedev/nestjsx-crud",
    usage: dedent(
      `
            import dataProvider from "@refinedev/nestjsx-crud";

            const App = () => {
                return (
                    <Refine
                        dataProvider={dataProvider("API_URL")}
                        /* ... */
                    >
                        {/* ... */}
                    </Refine>
                );
            };
            `.trim()
    )
  },
  {
    name: "@refinedev/react-hook-form",
    description: "React Hook Form integration for Refine",
    install: "npm install @refinedev/react-hook-form react-hook-form",
    usage: dedent(
      `
            import { useForm } from "@refinedev/react-hook-form";

            const EditPost = () => {
                const {
                    register,
                    handleSubmit,
                    formState,
                    refineCore,
                } = useForm({
                    refineCoreProps: {
                        resource: "posts",
                        id: "1",
                    },
                });

                return /* ... */
            };
            `.trim()
    )
  },
  {
    name: "@refinedev/react-table",
    description: "Tanstack React Table integration for Refine",
    install: "npm install @refinedev/react-table @tanstack/react-table",
    usage: dedent(
      `
            import { useTable } from "@refinedev/react-table";

            import { ColumnDef, flexRender } from "@tanstack/react-table";

            const EditPost = () => {
                const columns = React.useMemo<ColumnDef<IPost>[]>(
                    () => [
                        {
                            id: "id",
                            header: "ID",
                            accessorKey: "id",
                        },
                        {
                            id: "title",
                            header: "Title",
                            accessorKey: "title",
                            meta: {
                                filterOperator: "contains",
                            },
                        },
                ], []);

                const tableInstance = useTable({
                    columns,
                    refineCoreProps: {
                        resource: "posts",
                    }
                });

                return /* ... */
            };
            `.trim()
    )
  },
  {
    name: "@refinedev/simple-rest",
    description: "Data provider integration for REST APIs with Refine",
    install: "npm install @refinedev/simple-rest",
    usage: dedent(
      `
            import dataProvider from "@refinedev/simple-rest";

            const App = () => {
                return (
                    <Refine
                        dataProvider={dataProvider("API_URL")}
                        /* ... */
                    >
                        {/* ... */}
                    </Refine>
                );
            };
            `.trim()
    )
  },
  {
    name: "@refinedev/supabase",
    description: "Data provider and live provider integrations for Supabase with Refine",
    install: "npm install @refinedev/supabase",
    usage: dedent(
      `
            import { dataProvider, liveProvider, createClient } from "@refinedev/supabase";

            const supabaseClient = createClient("SUPABASE_URL", "SUPABASE_KEY");

            const App = () => {
                return (
                    <Refine
                        dataProvider={dataProvider(supabaseClient)}
                        liveProvider={liveProvider(supabaseClient)}
                        /* ... */
                    >
                        {/* ... */}
                    </Refine>
                );
            };
            `.trim()
    )
  },
  {
    name: "@refinedev/strapi",
    description: "Strapi integration of Refine",
    install: "npm install @refinedev/strapi axios",
    usage: dedent(
      `
            import { DataProvider, AuthHelper } from "@refinedev/strapi";

            const axiosInstance = axios.create();
            const strapiAuthHelper = AuthHelper("API_URL");

            const App = () => {
                return (
                    <Refine
                        dataProvider={DataProvider("API_URL", axiosInstance)}
                        /* ... */
                    >
                        {/* ... */}
                    </Refine>
                );
            };
            `.trim()
    )
  },
  {
    name: "@refinedev/strapi-v4",
    description: "StrapiV4 integration of Refine",
    install: "npm install @refinedev/strapi-v4 axios",
    usage: dedent(
      `
            import { DataProvider, AuthHelper } from "@refinedev/strapi-v4";

            const axiosInstance = axios.create();
            const strapiAuthHelper = AuthHelper("API_URL");

            const App = () => {
                return (
                    <Refine
                        dataProvider={DataProvider("API_URL", axiosInstance)}
                        /* ... */
                    >
                        {/* ... */}
                    </Refine>
                );
            };
            `.trim()
    )
  }
];
var getAvailablePackages = async (projectPath) => {
  const installedRefinePackages = await getPackagesFromPackageJSON(projectPath);
  return AVAILABLE_PACKAGES.filter(
    (p) => !installedRefinePackages.includes(p.name)
  );
};

// src/packages/update-package.ts
import { detect } from "package-manager-detector";
import execa from "execa";
var updatePackage = async (packages, projectPath = process.cwd()) => {
  try {
    const detected = await detect({ cwd: projectPath });
    const [pm] = ((detected == null ? void 0 : detected.agent) || "npm").split("@");
    const { failed } = await execa(pm, [
      "install",
      ...packages.map((p) => `${p}@latest`)
    ]);
    return !failed;
  } catch (error) {
    return false;
  }
};

// src/packages/get-latest-package-data.ts
import execa2 from "execa";
var getLatestPackageData = async (packageName) => {
  try {
    const { stdout } = await execa2("npm", [
      "view",
      packageName,
      "name",
      "version",
      "--json"
    ]);
    const parsed = JSON.parse(stdout);
    return parsed;
  } catch (e) {
    return { name: packageName };
  }
};

// src/project-id/get-project-id-from-package-json.ts
import { readJSON as readJSON2 } from "fs-extra";
import path4 from "path";
var getProjectIdFromPackageJson = async (projectPath = process.cwd()) => {
  var _a;
  try {
    const packageJson = await readJSON2(path4.join(projectPath, "package.json"), {
      encoding: "utf-8"
    });
    const projectId = (_a = packageJson == null ? void 0 : packageJson.refine) == null ? void 0 : _a.projectId;
    if (projectId) {
      return projectId;
    }
    return false;
  } catch (e) {
    return null;
  }
};

// src/project-id/set-project-id-to-package-json.ts
import execa3 from "execa";
var setProjectIdToPackageJson = async (projectId, projectPath = process.cwd()) => {
  try {
    execa3.sync("npm", ["pkg", "set", `refine.projectId=${projectId}`], {
      cwd: projectPath
    });
    return true;
  } catch (e) {
    return null;
  }
};

// src/project-id/set-project-id-to-refine-component.ts
import execa4 from "execa";
import path5 from "path";
var setProjectIdToRefineComponent = async (projectId, projectPath = process.cwd()) => {
  try {
    const jscodeshiftExecutable = __require.resolve(".bin/jscodeshift");
    const execution = execa4.sync(
      jscodeshiftExecutable,
      [
        "./",
        "--extensions=ts,tsx,js,jsx",
        "--parser=tsx",
        `--transform=${path5.resolve(
          path5.join(__dirname, "..", "src", "project-id", "transform.ts")
        )}`,
        "--ignore-pattern=**/.cache/**",
        "--ignore-pattern=**/node_modules/**",
        "--ignore-pattern=**/build/**",
        "--ignore-pattern=**/dist/**",
        "--ignore-pattern=**/.next/**",
        `--__projectId=${projectId}`
      ],
      {
        cwd: projectPath,
        timeout: 1e3 * 10
      }
    );
    if (execution.stderr) {
      console.error(execution.stderr);
    }
  } catch (error) {
    console.error(error);
  }
  return;
};

// src/project-id/update-project-id.ts
var updateProjectId = async (projectId, projectPath = process.cwd()) => {
  try {
    await Promise.all([
      setProjectIdToPackageJson(projectId, projectPath),
      setProjectIdToRefineComponent(projectId, projectPath)
    ]);
    return true;
  } catch (_) {
    return false;
  }
};

// src/serve-api.ts
var serveApi = (app, db) => {
  app.use("/api", json());
  app.get("/api/connected-app", (_, res) => {
    res.json({ url: db.connectedApp });
  });
  app.get("/api/activities", (req, res) => {
    const { offset = 0, limit = db.activities.length } = req.query;
    res.setHeader("x-total-count", db.activities.length);
    res.json({
      data: db.activities.slice(Number(offset), Number(limit))
    });
  });
  app.get("/api/activities/reset", (_, res) => {
    db.activities = [];
    res.json({ success: true });
  });
  app.get("/api/unique-trace-items", (req, res) => {
    res.header("Access-Control-Allow-Origin", "*");
    res.header(
      "Access-Control-Allow-Headers",
      "Origin, X-Requested-With, Content-Type, Accept"
    );
    const traceItems = db.activities.flatMap(
      (activity) => {
        var _a;
        return ((_a = activity.trace) == null ? void 0 : _a.map((t) => t.function).filter(Boolean)) ?? [];
      }
    );
    const uniqueTraceItems = uniq(traceItems);
    res.setHeader("x-total-count", uniqueTraceItems.length);
    res.json({ data: uniqueTraceItems });
  });
  let cachedInstalledPackages = null;
  app.get("/api/installed-packages", async (req, res) => {
    const { force } = req.query ?? {};
    if (!cachedInstalledPackages || force) {
      cachedInstalledPackages = await getAllPackages();
    }
    res.header("x-total-count", `${cachedInstalledPackages.length}`);
    res.json({ data: cachedInstalledPackages });
  });
  let cachedAvailablePackages = null;
  app.get("/api/available-packages", async (_, res) => {
    if (!cachedAvailablePackages) {
      cachedAvailablePackages = await getAvailablePackages();
    }
    res.header("x-total-count", `${cachedAvailablePackages.length}`);
    res.json({ data: cachedAvailablePackages });
  });
  const cachedLatestPackages = /* @__PURE__ */ new Map();
  app.get("/api/packages/:packageName/latest", async (req, res) => {
    const { packageName } = req.params ?? {};
    if (!packageName) {
      res.status(400).json({ error: "Package name is required" });
      return;
    }
    if (!cachedLatestPackages.has(packageName)) {
      const latest = await getLatestPackageData(packageName);
      cachedLatestPackages.set(packageName, latest);
    }
    return res.json({ data: cachedLatestPackages.get(packageName) });
  });
  app.post("/api/packages/install", async (req, res) => {
    const { packages } = req.body ?? {};
    if ((packages == null ? void 0 : packages.length) === 0) {
      res.status(400).json({ error: "Package name is required" });
      return;
    }
    const success = await updatePackage(packages);
    if (success) {
      cachedInstalledPackages = null;
      cachedAvailablePackages = null;
      res.status(200).json({ success: true });
    } else {
      res.status(400).json({
        success: false,
        error: "Failed to update package"
      });
    }
  });
  let cachedFeed = null;
  app.get("/api/feed", async (req, res) => {
    if (!cachedFeed) {
      cachedFeed = await getFeed();
    }
    res.header("x-total-count", `${cachedFeed.length}`);
    res.json({ data: cachedFeed });
  });
  app.get("/api/project-id/status", async (_, res) => {
    const CODES = {
      OK: 0,
      NOT_FOUND: 1,
      ERROR: 2
    };
    const projectId = await getProjectIdFromPackageJson();
    if (projectId) {
      res.status(200).json({ projectId, status: CODES.OK });
      return;
    }
    if (projectId === false) {
      res.status(200).json({ projectId: null, status: CODES.NOT_FOUND });
      return;
    }
    res.status(200).json({ projectId: null, status: CODES.ERROR });
    return;
  });
  app.post("/api/project-id/update", async (req, res) => {
    const { projectId } = req.body ?? {};
    if (!projectId) {
      res.status(400).json({ error: "Project ID is required" });
      return;
    }
    const success = await updateProjectId(projectId);
    if (success) {
      res.status(200).json({ success: true });
      return;
    }
    res.status(500).json({
      success: false,
      error: "Failed to update project ID"
    });
    return;
  });
};

// src/serve-proxy.ts
import path6 from "path";
import { readJSON as readJSON3, writeJSON } from "fs-extra";
import { createProxyMiddleware, fixRequestBody } from "http-proxy-middleware";
var persistPath = path6.join(__dirname, "..", ".persist.json");
var saveAuth = async (token, jwt) => {
  try {
    await writeJSON(persistPath, { token, jwt });
  } catch (error) {
  }
};
var loadAuth = async () => {
  try {
    return await readJSON3(persistPath);
  } catch (error) {
  }
  return {};
};
var serveProxy = async (app) => {
  let { token, jwt } = await loadAuth();
  const authProxy = createProxyMiddleware({
    target: `${AUTH_SERVER_URL}/api/.auth`,
    secure: false,
    changeOrigin: true,
    logger: false ? console : void 0,
    on: {
      proxyReq: fixRequestBody,
      proxyRes: (_proxyRes, req) => {
        var _a;
        if ((_a = req.url) == null ? void 0 : _a.includes("self-service/logout/api")) {
          token = void 0;
          jwt = void 0;
          saveAuth();
        }
      }
    }
  });
  const refineProxy = createProxyMiddleware({
    target: `${REFINE_API_URL}/.refine`,
    secure: false,
    changeOrigin: true,
    logger: false ? console : void 0,
    on: {
      proxyReq: fixRequestBody
    }
  });
  let currentProjectId = null;
  const projectIdAppender = async (req, _res, next) => {
    if (!currentProjectId) {
      currentProjectId = await getProjectIdFromPackageJson();
    }
    if (currentProjectId) {
      req.headers["x-project-id"] = currentProjectId;
    }
    next();
  };
  const appendAuth = async (req, _res, next) => {
    var _a;
    if (token) {
      req.headers["X-Session-Token"] = token;
    }
    if ((_a = req.url) == null ? void 0 : _a.includes("self-service/logout/api")) {
      req.body = {
        session_token: token
      };
      req.headers["Content-Length"] = Buffer.byteLength(
        JSON.stringify(req.body)
      ).toString();
    }
    next();
  };
  const appendJwt = async (req, _res, next) => {
    if (jwt) {
      req.headers["Authorization"] = `Bearer ${jwt}`;
      delete req.headers["cookie"];
    }
    next();
  };
  const loginCallback = async (req, res, _next) => {
    const query = req.query;
    if (query.token && query.jwt) {
      token = query.token;
      jwt = query.jwt;
      await saveAuth(query.token, query.jwt);
    }
    const errorParams = new URLSearchParams();
    if (query.error) {
      errorParams.set("error", query.error);
    }
    if (query.code) {
      errorParams.set("code", query.code);
    }
    res.redirect(`${AUTH_CALLBACK_UI_PATH}?${errorParams.toString()}`);
  };
  const loginTrigger = async (req, res, _next) => {
    const query = req.query;
    const protocol = req.secure ? "https" : "http";
    const host = req.headers.host;
    if (!host) {
      res.redirect(`${AUTH_CALLBACK_API_PATH}?error=Missing%20Host`);
      return;
    }
    const callbackUrl = `${protocol}://${host}${AUTH_CALLBACK_API_PATH}`;
    const params = new URLSearchParams({
      provider: query.provider,
      returnUrl: encodeURIComponent(callbackUrl)
    });
    res.redirect(`${AUTH_SERVER_URL}/login?${params.toString()}`);
  };
  app.use(AUTH_TRIGGER_API_PATH, loginTrigger);
  app.use(AUTH_CALLBACK_API_PATH, loginCallback);
  app.use("/api/.auth", appendAuth, authProxy);
  app.use("/api/.refine", projectIdAppender, appendJwt, refineProxy);
};

// src/serve-open-in-editor.ts
import path7 from "path";
var serveOpenInEditor = (app, basePath) => {
  app.get("/open-in-editor/*", (req, res) => {
    const { line, column } = req.query;
    const filePath = req.path.replace("/open-in-editor", "");
    const vscodeUrl = `vscode://file/${path7.join(basePath, filePath)}?${line ? `line=${line}` : ""}${column ? `&column=${column}` : ""}`;
    res.redirect(vscodeUrl);
  });
};

// src/index.ts
var server = async ({
  projectPath = process.cwd(),
  onError = () => {
    process.exit(1);
  }
} = {}) => {
  return new Promise((_, reject) => {
    const app = express2();
    const server2 = setupServer(app, () => {
      reject();
      onError();
    });
    const ws = serveWs(server2, () => {
      reject();
      onError();
    });
    const db = createDb();
    ws.on("connection", (client) => {
      receive(client, DevtoolsEvent2.DEVTOOLS_INIT, (data) => {
        if (db.connectedApp) {
          send2(client, DevtoolsEvent2.DEVTOOLS_ALREADY_CONNECTED, {
            url: db.connectedApp
          });
        } else {
          db.connectedApp = data.url;
          db.clientWs = client;
          ws.clients.forEach((c) => {
            send2(c, DevtoolsEvent2.DEVTOOLS_CONNECTED_APP, {
              url: db.connectedApp
            });
          });
        }
      });
      receive(client, DevtoolsEvent2.ACTIVITY, (data) => {
        const index = db.activities.findIndex(
          (activity) => activity.identifier === data.identifier
        );
        const record = {
          ...data,
          createdAt: Date.now(),
          updatedAt: Date.now()
        };
        if (index > -1) {
          record.createdAt = db.activities[index].createdAt;
          db.activities[index] = record;
        } else {
          db.activities.push(record);
        }
        ws.clients.forEach((c) => {
          send2(c, DevtoolsEvent2.DEVTOOLS_ACTIVITY_UPDATE, {
            updatedActivities: [record]
          });
        });
      });
      receive(
        client,
        DevtoolsEvent2.DEVTOOLS_HIGHLIGHT_IN_MONITOR,
        ({ name }) => {
          ws.clients.forEach((c) => {
            send2(c, DevtoolsEvent2.DEVTOOLS_HIGHLIGHT_IN_MONITOR_ACTION, {
              name
            });
          });
        }
      );
      receive(
        client,
        DevtoolsEvent2.DEVTOOLS_INVALIDATE_QUERY,
        ({ queryKey }) => {
          ws.clients.forEach((c) => {
            send2(c, DevtoolsEvent2.DEVTOOLS_INVALIDATE_QUERY_ACTION, {
              queryKey
            });
          });
        }
      );
      receive(client, DevtoolsEvent2.DEVTOOLS_LOGIN_SUCCESS, () => {
        ws.clients.forEach((c) => {
          send2(c, DevtoolsEvent2.DEVTOOLS_RELOAD_AFTER_LOGIN, {});
        });
      });
      receive(
        client,
        DevtoolsEvent2.DEVTOOLS_LOGIN_FAILURE,
        ({ error, code }) => {
          ws.clients.forEach((c) => {
            send2(c, DevtoolsEvent2.DEVTOOLS_DISPLAY_LOGIN_FAILURE, {
              error,
              code
            });
          });
        }
      );
      client.on("close", (_2, reason) => {
        if (false) {
          console.log("Client disconnected", ws.clients.size);
        }
        if (db.clientWs) {
          if (!ws.clients.has(db.clientWs)) {
            db.clientWs = null;
            db.connectedApp = null;
            db.activities = [];
            ws.clients.forEach((c) => {
              send2(c, DevtoolsEvent2.DEVTOOLS_DISCONNECTED_APP, {
                url: db.connectedApp
              });
            });
          }
        }
      });
      if (false) {
        console.log("Client connected", ws.clients.size);
      }
    });
    reloadOnChange(ws);
    serveClient(app);
    serveApi(app, db);
    serveProxy(app);
    serveOpenInEditor(app, projectPath);
    process.on("SIGTERM", () => {
      reject();
    });
  });
};
export {
  server
};
//# sourceMappingURL=index.mjs.map